// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/rnr-capital/newsfeed-backend/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Column() ColumnResolver
	Feed() FeedResolver
	Mutation() MutationResolver
	Post() PostResolver
	Query() QueryResolver
	Source() SourceResolver
	SubSource() SubSourceResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Column struct {
		CreatedAt                 func(childComplexity int) int
		Creator                   func(childComplexity int) int
		Feeds                     func(childComplexity int) int
		Id                        func(childComplexity int) int
		MobileNotification        func(childComplexity int) int
		Name                      func(childComplexity int) int
		Readed                    func(childComplexity int) int
		ShowUnreadIndicatorOnIcon func(childComplexity int) int
		SubscriberCount           func(childComplexity int) int
		Subscribers               func(childComplexity int) int
		UpdatedAt                 func(childComplexity int) int
		Visibility                func(childComplexity int) int
		WebNotification           func(childComplexity int) int
	}

	ColumnSeedState struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	CustomizedCrawlerTestResponse struct {
		BaseHTML   func(childComplexity int) int
		Content    func(childComplexity int) int
		ExternalID func(childComplexity int) int
		Images     func(childComplexity int) int
		OriginURL  func(childComplexity int) int
		Subsource  func(childComplexity int) int
		Time       func(childComplexity int) int
		Title      func(childComplexity int) int
	}

	Feed struct {
		Columns              func(childComplexity int) int
		CreatedAt            func(childComplexity int) int
		Creator              func(childComplexity int) int
		FilterDataExpression func(childComplexity int) int
		Id                   func(childComplexity int) int
		Name                 func(childComplexity int) int
		Posts                func(childComplexity int) int
		SubSources           func(childComplexity int) int
		UpdatedAt            func(childComplexity int) int
		Visibility           func(childComplexity int) int
	}

	FeedSeedState struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Mutation struct {
		AddSubSource           func(childComplexity int, input model.AddSubSourceInput) int
		AddWeiboSubSource      func(childComplexity int, input model.AddWeiboSubSourceInput) int
		CreatePost             func(childComplexity int, input model.NewPostInput) int
		CreateSource           func(childComplexity int, input model.NewSourceInput) int
		CreateUser             func(childComplexity int, input model.NewUserInput) int
		DeleteColumn           func(childComplexity int, input model.DeleteColumnInput) int
		DeleteSubSource        func(childComplexity int, input *model.DeleteSubSourceInput) int
		SetFeedFavorite        func(childComplexity int, input model.SetFeedFavoriteInput) int
		SetItemsReadStatus     func(childComplexity int, input model.SetItemsReadStatusInput) int
		SetNotificationSetting func(childComplexity int, input model.NotificationSettingInput) int
		Subscribe              func(childComplexity int, input model.SubscribeInput) int
		SyncUp                 func(childComplexity int, input *model.SeedStateInput) int
		UpsertColumn           func(childComplexity int, input model.UpsertColumnInput) int
		UpsertFeed             func(childComplexity int, input model.UpsertFeedInput) int
		UpsertSubSource        func(childComplexity int, input model.UpsertSubSourceInput) int
	}

	Post struct {
		Content            func(childComplexity int) int
		ContentGeneratedAt func(childComplexity int) int
		CrawledAt          func(childComplexity int) int
		CreatedAt          func(childComplexity int) int
		Cursor             func(childComplexity int) int
		DeduplicateId      func(childComplexity int) int
		Delayed            func(childComplexity int) int
		DeletedAt          func(childComplexity int) int
		Embedding          func(childComplexity int) int
		FileUrls           func(childComplexity int) int
		Id                 func(childComplexity int) int
		ImageUrls          func(childComplexity int) int
		InSharingChain     func(childComplexity int) int
		IsRead             func(childComplexity int) int
		OriginUrl          func(childComplexity int) int
		PublishedFeeds     func(childComplexity int) int
		ReadByUser         func(childComplexity int) int
		ReplyThread        func(childComplexity int) int
		SemanticHashing    func(childComplexity int) int
		SharedFromPost     func(childComplexity int) int
		SubSource          func(childComplexity int) int
		Tags               func(childComplexity int) int
		Title              func(childComplexity int) int
	}

	PostInColumnOutput struct {
		Cursor func(childComplexity int) int
		Post   func(childComplexity int) int
	}

	PostInFeedOutput struct {
		Cursor func(childComplexity int) int
		Post   func(childComplexity int) int
	}

	Query struct {
		AllVisibleColumns    func(childComplexity int) int
		Columns              func(childComplexity int, input *model.ColumnsGetPostsInput) int
		FavoriteFeeds        func(childComplexity int, input *model.UserIDInput) int
		Feeds                func(childComplexity int, input *model.FeedsGetPostsInput) int
		Post                 func(childComplexity int, input *model.PostInput) int
		Posts                func(childComplexity int, input *model.SearchPostsInput) int
		Sources              func(childComplexity int, input *model.SourcesInput) int
		SubSources           func(childComplexity int, input *model.SubsourcesInput) int
		TryCustomizedCrawler func(childComplexity int, input *model.CustomizedCrawlerParams) int
		UserState            func(childComplexity int, input model.UserStateInput) int
		Users                func(childComplexity int) int
	}

	SeedState struct {
		ColumnSeedState func(childComplexity int) int
		UserSeedState   func(childComplexity int) int
	}

	Signal struct {
		SignalPayload func(childComplexity int) int
		SignalType    func(childComplexity int) int
	}

	Source struct {
		CreatedAt  func(childComplexity int) int
		Creator    func(childComplexity int) int
		DeletedAt  func(childComplexity int) int
		Domain     func(childComplexity int) int
		Id         func(childComplexity int) int
		Name       func(childComplexity int) int
		SubSources func(childComplexity int) int
	}

	SubSource struct {
		AvatarUrl               func(childComplexity int) int
		CreatedAt               func(childComplexity int) int
		CustomizedCrawlerParams func(childComplexity int) int
		DeletedAt               func(childComplexity int) int
		ExternalIdentifier      func(childComplexity int) int
		Id                      func(childComplexity int) int
		IsFromSharedPost        func(childComplexity int) int
		Name                    func(childComplexity int) int
		OriginUrl               func(childComplexity int) int
		Source                  func(childComplexity int) int
	}

	Subscription struct {
		Signal func(childComplexity int, userID string) int
	}

	User struct {
		AvatarUrl         func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Id                func(childComplexity int) int
		Name              func(childComplexity int) int
		PostsRead         func(childComplexity int) int
		SubscribedColumns func(childComplexity int) int
	}

	UserSeedState struct {
		AvatarURL func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
	}

	UserState struct {
		User func(childComplexity int) int
	}
}

type ColumnResolver interface {
	SubscriberCount(ctx context.Context, obj *model.Column) (*int, error)
	MobileNotification(ctx context.Context, obj *model.Column) (bool, error)

	WebNotification(ctx context.Context, obj *model.Column) (bool, error)
	ShowUnreadIndicatorOnIcon(ctx context.Context, obj *model.Column) (bool, error)
}
type FeedResolver interface {
	FilterDataExpression(ctx context.Context, obj *model.Feed) (string, error)
}
type MutationResolver interface {
	CreateUser(ctx context.Context, input model.NewUserInput) (*model.User, error)
	UpsertFeed(ctx context.Context, input model.UpsertFeedInput) (*model.Feed, error)
	UpsertColumn(ctx context.Context, input model.UpsertColumnInput) (*model.Column, error)
	DeleteColumn(ctx context.Context, input model.DeleteColumnInput) (*model.Column, error)
	CreatePost(ctx context.Context, input model.NewPostInput) (*model.Post, error)
	Subscribe(ctx context.Context, input model.SubscribeInput) (*model.User, error)
	CreateSource(ctx context.Context, input model.NewSourceInput) (*model.Source, error)
	UpsertSubSource(ctx context.Context, input model.UpsertSubSourceInput) (*model.SubSource, error)
	AddWeiboSubSource(ctx context.Context, input model.AddWeiboSubSourceInput) (*model.SubSource, error)
	AddSubSource(ctx context.Context, input model.AddSubSourceInput) (*model.SubSource, error)
	DeleteSubSource(ctx context.Context, input *model.DeleteSubSourceInput) (*model.SubSource, error)
	SyncUp(ctx context.Context, input *model.SeedStateInput) (*model.SeedState, error)
	SetItemsReadStatus(ctx context.Context, input model.SetItemsReadStatusInput) (bool, error)
	SetFeedFavorite(ctx context.Context, input model.SetFeedFavoriteInput) (bool, error)
	SetNotificationSetting(ctx context.Context, input model.NotificationSettingInput) (bool, error)
}
type PostResolver interface {
	DeletedAt(ctx context.Context, obj *model.Post) (*time.Time, error)

	ImageUrls(ctx context.Context, obj *model.Post) ([]string, error)
	FileUrls(ctx context.Context, obj *model.Post) ([]string, error)

	Embedding(ctx context.Context, obj *model.Post) ([]float64, error)

	Tags(ctx context.Context, obj *model.Post) ([]string, error)
}
type QueryResolver interface {
	AllVisibleColumns(ctx context.Context) ([]*model.Column, error)
	FavoriteFeeds(ctx context.Context, input *model.UserIDInput) ([]*model.Feed, error)
	Post(ctx context.Context, input *model.PostInput) (*model.Post, error)
	Posts(ctx context.Context, input *model.SearchPostsInput) ([]*model.Post, error)
	Users(ctx context.Context) ([]*model.User, error)
	UserState(ctx context.Context, input model.UserStateInput) (*model.UserState, error)
	Feeds(ctx context.Context, input *model.FeedsGetPostsInput) ([]*model.Feed, error)
	Columns(ctx context.Context, input *model.ColumnsGetPostsInput) ([]*model.Column, error)
	SubSources(ctx context.Context, input *model.SubsourcesInput) ([]*model.SubSource, error)
	Sources(ctx context.Context, input *model.SourcesInput) ([]*model.Source, error)
	TryCustomizedCrawler(ctx context.Context, input *model.CustomizedCrawlerParams) ([]*model.CustomizedCrawlerTestResponse, error)
}
type SourceResolver interface {
	DeletedAt(ctx context.Context, obj *model.Source) (*time.Time, error)
}
type SubSourceResolver interface {
	DeletedAt(ctx context.Context, obj *model.SubSource) (*time.Time, error)

	Source(ctx context.Context, obj *model.SubSource) (*model.Source, error)
}
type SubscriptionResolver interface {
	Signal(ctx context.Context, userID string) (<-chan *model.Signal, error)
}
type UserResolver interface {
	DeletedAt(ctx context.Context, obj *model.User) (*time.Time, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Column.createdAt":
		if e.complexity.Column.CreatedAt == nil {
			break
		}

		return e.complexity.Column.CreatedAt(childComplexity), true

	case "Column.creator":
		if e.complexity.Column.Creator == nil {
			break
		}

		return e.complexity.Column.Creator(childComplexity), true

	case "Column.feeds":
		if e.complexity.Column.Feeds == nil {
			break
		}

		return e.complexity.Column.Feeds(childComplexity), true

	case "Column.id":
		if e.complexity.Column.Id == nil {
			break
		}

		return e.complexity.Column.Id(childComplexity), true

	case "Column.mobileNotification":
		if e.complexity.Column.MobileNotification == nil {
			break
		}

		return e.complexity.Column.MobileNotification(childComplexity), true

	case "Column.name":
		if e.complexity.Column.Name == nil {
			break
		}

		return e.complexity.Column.Name(childComplexity), true

	case "Column.readed":
		if e.complexity.Column.Readed == nil {
			break
		}

		return e.complexity.Column.Readed(childComplexity), true

	case "Column.showUnreadIndicatorOnIcon":
		if e.complexity.Column.ShowUnreadIndicatorOnIcon == nil {
			break
		}

		return e.complexity.Column.ShowUnreadIndicatorOnIcon(childComplexity), true

	case "Column.subscriberCount":
		if e.complexity.Column.SubscriberCount == nil {
			break
		}

		return e.complexity.Column.SubscriberCount(childComplexity), true

	case "Column.subscribers":
		if e.complexity.Column.Subscribers == nil {
			break
		}

		return e.complexity.Column.Subscribers(childComplexity), true

	case "Column.updatedAt":
		if e.complexity.Column.UpdatedAt == nil {
			break
		}

		return e.complexity.Column.UpdatedAt(childComplexity), true

	case "Column.visibility":
		if e.complexity.Column.Visibility == nil {
			break
		}

		return e.complexity.Column.Visibility(childComplexity), true

	case "Column.webNotification":
		if e.complexity.Column.WebNotification == nil {
			break
		}

		return e.complexity.Column.WebNotification(childComplexity), true

	case "ColumnSeedState.id":
		if e.complexity.ColumnSeedState.ID == nil {
			break
		}

		return e.complexity.ColumnSeedState.ID(childComplexity), true

	case "ColumnSeedState.name":
		if e.complexity.ColumnSeedState.Name == nil {
			break
		}

		return e.complexity.ColumnSeedState.Name(childComplexity), true

	case "CustomizedCrawlerTestResponse.baseHtml":
		if e.complexity.CustomizedCrawlerTestResponse.BaseHTML == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.BaseHTML(childComplexity), true

	case "CustomizedCrawlerTestResponse.content":
		if e.complexity.CustomizedCrawlerTestResponse.Content == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Content(childComplexity), true

	case "CustomizedCrawlerTestResponse.externalId":
		if e.complexity.CustomizedCrawlerTestResponse.ExternalID == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.ExternalID(childComplexity), true

	case "CustomizedCrawlerTestResponse.images":
		if e.complexity.CustomizedCrawlerTestResponse.Images == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Images(childComplexity), true

	case "CustomizedCrawlerTestResponse.originUrl":
		if e.complexity.CustomizedCrawlerTestResponse.OriginURL == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.OriginURL(childComplexity), true

	case "CustomizedCrawlerTestResponse.subsource":
		if e.complexity.CustomizedCrawlerTestResponse.Subsource == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Subsource(childComplexity), true

	case "CustomizedCrawlerTestResponse.time":
		if e.complexity.CustomizedCrawlerTestResponse.Time == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Time(childComplexity), true

	case "CustomizedCrawlerTestResponse.title":
		if e.complexity.CustomizedCrawlerTestResponse.Title == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Title(childComplexity), true

	case "Feed.columns":
		if e.complexity.Feed.Columns == nil {
			break
		}

		return e.complexity.Feed.Columns(childComplexity), true

	case "Feed.createdAt":
		if e.complexity.Feed.CreatedAt == nil {
			break
		}

		return e.complexity.Feed.CreatedAt(childComplexity), true

	case "Feed.creator":
		if e.complexity.Feed.Creator == nil {
			break
		}

		return e.complexity.Feed.Creator(childComplexity), true

	case "Feed.filterDataExpression":
		if e.complexity.Feed.FilterDataExpression == nil {
			break
		}

		return e.complexity.Feed.FilterDataExpression(childComplexity), true

	case "Feed.id":
		if e.complexity.Feed.Id == nil {
			break
		}

		return e.complexity.Feed.Id(childComplexity), true

	case "Feed.name":
		if e.complexity.Feed.Name == nil {
			break
		}

		return e.complexity.Feed.Name(childComplexity), true

	case "Feed.posts":
		if e.complexity.Feed.Posts == nil {
			break
		}

		return e.complexity.Feed.Posts(childComplexity), true

	case "Feed.subSources":
		if e.complexity.Feed.SubSources == nil {
			break
		}

		return e.complexity.Feed.SubSources(childComplexity), true

	case "Feed.updatedAt":
		if e.complexity.Feed.UpdatedAt == nil {
			break
		}

		return e.complexity.Feed.UpdatedAt(childComplexity), true

	case "Feed.visibility":
		if e.complexity.Feed.Visibility == nil {
			break
		}

		return e.complexity.Feed.Visibility(childComplexity), true

	case "FeedSeedState.id":
		if e.complexity.FeedSeedState.ID == nil {
			break
		}

		return e.complexity.FeedSeedState.ID(childComplexity), true

	case "FeedSeedState.name":
		if e.complexity.FeedSeedState.Name == nil {
			break
		}

		return e.complexity.FeedSeedState.Name(childComplexity), true

	case "Mutation.addSubSource":
		if e.complexity.Mutation.AddSubSource == nil {
			break
		}

		args, err := ec.field_Mutation_addSubSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddSubSource(childComplexity, args["input"].(model.AddSubSourceInput)), true

	case "Mutation.addWeiboSubSource":
		if e.complexity.Mutation.AddWeiboSubSource == nil {
			break
		}

		args, err := ec.field_Mutation_addWeiboSubSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddWeiboSubSource(childComplexity, args["input"].(model.AddWeiboSubSourceInput)), true

	case "Mutation.createPost":
		if e.complexity.Mutation.CreatePost == nil {
			break
		}

		args, err := ec.field_Mutation_createPost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePost(childComplexity, args["input"].(model.NewPostInput)), true

	case "Mutation.createSource":
		if e.complexity.Mutation.CreateSource == nil {
			break
		}

		args, err := ec.field_Mutation_createSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSource(childComplexity, args["input"].(model.NewSourceInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.NewUserInput)), true

	case "Mutation.deleteColumn":
		if e.complexity.Mutation.DeleteColumn == nil {
			break
		}

		args, err := ec.field_Mutation_deleteColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteColumn(childComplexity, args["input"].(model.DeleteColumnInput)), true

	case "Mutation.deleteSubSource":
		if e.complexity.Mutation.DeleteSubSource == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSubSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSubSource(childComplexity, args["input"].(*model.DeleteSubSourceInput)), true

	case "Mutation.setFeedFavorite":
		if e.complexity.Mutation.SetFeedFavorite == nil {
			break
		}

		args, err := ec.field_Mutation_setFeedFavorite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetFeedFavorite(childComplexity, args["input"].(model.SetFeedFavoriteInput)), true

	case "Mutation.setItemsReadStatus":
		if e.complexity.Mutation.SetItemsReadStatus == nil {
			break
		}

		args, err := ec.field_Mutation_setItemsReadStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetItemsReadStatus(childComplexity, args["input"].(model.SetItemsReadStatusInput)), true

	case "Mutation.setNotificationSetting":
		if e.complexity.Mutation.SetNotificationSetting == nil {
			break
		}

		args, err := ec.field_Mutation_setNotificationSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetNotificationSetting(childComplexity, args["input"].(model.NotificationSettingInput)), true

	case "Mutation.subscribe":
		if e.complexity.Mutation.Subscribe == nil {
			break
		}

		args, err := ec.field_Mutation_subscribe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Subscribe(childComplexity, args["input"].(model.SubscribeInput)), true

	case "Mutation.syncUp":
		if e.complexity.Mutation.SyncUp == nil {
			break
		}

		args, err := ec.field_Mutation_syncUp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncUp(childComplexity, args["input"].(*model.SeedStateInput)), true

	case "Mutation.upsertColumn":
		if e.complexity.Mutation.UpsertColumn == nil {
			break
		}

		args, err := ec.field_Mutation_upsertColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertColumn(childComplexity, args["input"].(model.UpsertColumnInput)), true

	case "Mutation.upsertFeed":
		if e.complexity.Mutation.UpsertFeed == nil {
			break
		}

		args, err := ec.field_Mutation_upsertFeed_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertFeed(childComplexity, args["input"].(model.UpsertFeedInput)), true

	case "Mutation.upsertSubSource":
		if e.complexity.Mutation.UpsertSubSource == nil {
			break
		}

		args, err := ec.field_Mutation_upsertSubSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertSubSource(childComplexity, args["input"].(model.UpsertSubSourceInput)), true

	case "Post.content":
		if e.complexity.Post.Content == nil {
			break
		}

		return e.complexity.Post.Content(childComplexity), true

	case "Post.contentGeneratedAt":
		if e.complexity.Post.ContentGeneratedAt == nil {
			break
		}

		return e.complexity.Post.ContentGeneratedAt(childComplexity), true

	case "Post.crawledAt":
		if e.complexity.Post.CrawledAt == nil {
			break
		}

		return e.complexity.Post.CrawledAt(childComplexity), true

	case "Post.createdAt":
		if e.complexity.Post.CreatedAt == nil {
			break
		}

		return e.complexity.Post.CreatedAt(childComplexity), true

	case "Post.cursor":
		if e.complexity.Post.Cursor == nil {
			break
		}

		return e.complexity.Post.Cursor(childComplexity), true

	case "Post.deduplicateId":
		if e.complexity.Post.DeduplicateId == nil {
			break
		}

		return e.complexity.Post.DeduplicateId(childComplexity), true

	case "Post.delayed":
		if e.complexity.Post.Delayed == nil {
			break
		}

		return e.complexity.Post.Delayed(childComplexity), true

	case "Post.deletedAt":
		if e.complexity.Post.DeletedAt == nil {
			break
		}

		return e.complexity.Post.DeletedAt(childComplexity), true

	case "Post.embedding":
		if e.complexity.Post.Embedding == nil {
			break
		}

		return e.complexity.Post.Embedding(childComplexity), true

	case "Post.fileUrls":
		if e.complexity.Post.FileUrls == nil {
			break
		}

		return e.complexity.Post.FileUrls(childComplexity), true

	case "Post.id":
		if e.complexity.Post.Id == nil {
			break
		}

		return e.complexity.Post.Id(childComplexity), true

	case "Post.imageUrls":
		if e.complexity.Post.ImageUrls == nil {
			break
		}

		return e.complexity.Post.ImageUrls(childComplexity), true

	case "Post.inSharingChain":
		if e.complexity.Post.InSharingChain == nil {
			break
		}

		return e.complexity.Post.InSharingChain(childComplexity), true

	case "Post.isRead":
		if e.complexity.Post.IsRead == nil {
			break
		}

		return e.complexity.Post.IsRead(childComplexity), true

	case "Post.originUrl":
		if e.complexity.Post.OriginUrl == nil {
			break
		}

		return e.complexity.Post.OriginUrl(childComplexity), true

	case "Post.publishedFeeds":
		if e.complexity.Post.PublishedFeeds == nil {
			break
		}

		return e.complexity.Post.PublishedFeeds(childComplexity), true

	case "Post.readByUser":
		if e.complexity.Post.ReadByUser == nil {
			break
		}

		return e.complexity.Post.ReadByUser(childComplexity), true

	case "Post.replyThread":
		if e.complexity.Post.ReplyThread == nil {
			break
		}

		return e.complexity.Post.ReplyThread(childComplexity), true

	case "Post.semanticHashing":
		if e.complexity.Post.SemanticHashing == nil {
			break
		}

		return e.complexity.Post.SemanticHashing(childComplexity), true

	case "Post.sharedFromPost":
		if e.complexity.Post.SharedFromPost == nil {
			break
		}

		return e.complexity.Post.SharedFromPost(childComplexity), true

	case "Post.subSource":
		if e.complexity.Post.SubSource == nil {
			break
		}

		return e.complexity.Post.SubSource(childComplexity), true

	case "Post.tags":
		if e.complexity.Post.Tags == nil {
			break
		}

		return e.complexity.Post.Tags(childComplexity), true

	case "Post.title":
		if e.complexity.Post.Title == nil {
			break
		}

		return e.complexity.Post.Title(childComplexity), true

	case "PostInColumnOutput.cursor":
		if e.complexity.PostInColumnOutput.Cursor == nil {
			break
		}

		return e.complexity.PostInColumnOutput.Cursor(childComplexity), true

	case "PostInColumnOutput.post":
		if e.complexity.PostInColumnOutput.Post == nil {
			break
		}

		return e.complexity.PostInColumnOutput.Post(childComplexity), true

	case "PostInFeedOutput.cursor":
		if e.complexity.PostInFeedOutput.Cursor == nil {
			break
		}

		return e.complexity.PostInFeedOutput.Cursor(childComplexity), true

	case "PostInFeedOutput.post":
		if e.complexity.PostInFeedOutput.Post == nil {
			break
		}

		return e.complexity.PostInFeedOutput.Post(childComplexity), true

	case "Query.allVisibleColumns":
		if e.complexity.Query.AllVisibleColumns == nil {
			break
		}

		return e.complexity.Query.AllVisibleColumns(childComplexity), true

	case "Query.columns":
		if e.complexity.Query.Columns == nil {
			break
		}

		args, err := ec.field_Query_columns_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Columns(childComplexity, args["input"].(*model.ColumnsGetPostsInput)), true

	case "Query.favoriteFeeds":
		if e.complexity.Query.FavoriteFeeds == nil {
			break
		}

		args, err := ec.field_Query_favoriteFeeds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FavoriteFeeds(childComplexity, args["input"].(*model.UserIDInput)), true

	case "Query.feeds":
		if e.complexity.Query.Feeds == nil {
			break
		}

		args, err := ec.field_Query_feeds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Feeds(childComplexity, args["input"].(*model.FeedsGetPostsInput)), true

	case "Query.post":
		if e.complexity.Query.Post == nil {
			break
		}

		args, err := ec.field_Query_post_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Post(childComplexity, args["input"].(*model.PostInput)), true

	case "Query.posts":
		if e.complexity.Query.Posts == nil {
			break
		}

		args, err := ec.field_Query_posts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Posts(childComplexity, args["input"].(*model.SearchPostsInput)), true

	case "Query.sources":
		if e.complexity.Query.Sources == nil {
			break
		}

		args, err := ec.field_Query_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sources(childComplexity, args["input"].(*model.SourcesInput)), true

	case "Query.subSources":
		if e.complexity.Query.SubSources == nil {
			break
		}

		args, err := ec.field_Query_subSources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SubSources(childComplexity, args["input"].(*model.SubsourcesInput)), true

	case "Query.tryCustomizedCrawler":
		if e.complexity.Query.TryCustomizedCrawler == nil {
			break
		}

		args, err := ec.field_Query_tryCustomizedCrawler_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TryCustomizedCrawler(childComplexity, args["input"].(*model.CustomizedCrawlerParams)), true

	case "Query.userState":
		if e.complexity.Query.UserState == nil {
			break
		}

		args, err := ec.field_Query_userState_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserState(childComplexity, args["input"].(model.UserStateInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "SeedState.columnSeedState":
		if e.complexity.SeedState.ColumnSeedState == nil {
			break
		}

		return e.complexity.SeedState.ColumnSeedState(childComplexity), true

	case "SeedState.userSeedState":
		if e.complexity.SeedState.UserSeedState == nil {
			break
		}

		return e.complexity.SeedState.UserSeedState(childComplexity), true

	case "Signal.signalPayload":
		if e.complexity.Signal.SignalPayload == nil {
			break
		}

		return e.complexity.Signal.SignalPayload(childComplexity), true

	case "Signal.signalType":
		if e.complexity.Signal.SignalType == nil {
			break
		}

		return e.complexity.Signal.SignalType(childComplexity), true

	case "Source.createdAt":
		if e.complexity.Source.CreatedAt == nil {
			break
		}

		return e.complexity.Source.CreatedAt(childComplexity), true

	case "Source.creator":
		if e.complexity.Source.Creator == nil {
			break
		}

		return e.complexity.Source.Creator(childComplexity), true

	case "Source.deletedAt":
		if e.complexity.Source.DeletedAt == nil {
			break
		}

		return e.complexity.Source.DeletedAt(childComplexity), true

	case "Source.domain":
		if e.complexity.Source.Domain == nil {
			break
		}

		return e.complexity.Source.Domain(childComplexity), true

	case "Source.id":
		if e.complexity.Source.Id == nil {
			break
		}

		return e.complexity.Source.Id(childComplexity), true

	case "Source.name":
		if e.complexity.Source.Name == nil {
			break
		}

		return e.complexity.Source.Name(childComplexity), true

	case "Source.subsources":
		if e.complexity.Source.SubSources == nil {
			break
		}

		return e.complexity.Source.SubSources(childComplexity), true

	case "SubSource.avatarUrl":
		if e.complexity.SubSource.AvatarUrl == nil {
			break
		}

		return e.complexity.SubSource.AvatarUrl(childComplexity), true

	case "SubSource.createdAt":
		if e.complexity.SubSource.CreatedAt == nil {
			break
		}

		return e.complexity.SubSource.CreatedAt(childComplexity), true

	case "SubSource.customizedCrawlerParams":
		if e.complexity.SubSource.CustomizedCrawlerParams == nil {
			break
		}

		return e.complexity.SubSource.CustomizedCrawlerParams(childComplexity), true

	case "SubSource.deletedAt":
		if e.complexity.SubSource.DeletedAt == nil {
			break
		}

		return e.complexity.SubSource.DeletedAt(childComplexity), true

	case "SubSource.externalIdentifier":
		if e.complexity.SubSource.ExternalIdentifier == nil {
			break
		}

		return e.complexity.SubSource.ExternalIdentifier(childComplexity), true

	case "SubSource.id":
		if e.complexity.SubSource.Id == nil {
			break
		}

		return e.complexity.SubSource.Id(childComplexity), true

	case "SubSource.isFromSharedPost":
		if e.complexity.SubSource.IsFromSharedPost == nil {
			break
		}

		return e.complexity.SubSource.IsFromSharedPost(childComplexity), true

	case "SubSource.name":
		if e.complexity.SubSource.Name == nil {
			break
		}

		return e.complexity.SubSource.Name(childComplexity), true

	case "SubSource.originUrl":
		if e.complexity.SubSource.OriginUrl == nil {
			break
		}

		return e.complexity.SubSource.OriginUrl(childComplexity), true

	case "SubSource.source":
		if e.complexity.SubSource.Source == nil {
			break
		}

		return e.complexity.SubSource.Source(childComplexity), true

	case "Subscription.signal":
		if e.complexity.Subscription.Signal == nil {
			break
		}

		args, err := ec.field_Subscription_signal_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Signal(childComplexity, args["userId"].(string)), true

	case "User.avatarUrl":
		if e.complexity.User.AvatarUrl == nil {
			break
		}

		return e.complexity.User.AvatarUrl(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.deletedAt":
		if e.complexity.User.DeletedAt == nil {
			break
		}

		return e.complexity.User.DeletedAt(childComplexity), true

	case "User.id":
		if e.complexity.User.Id == nil {
			break
		}

		return e.complexity.User.Id(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.postsRead":
		if e.complexity.User.PostsRead == nil {
			break
		}

		return e.complexity.User.PostsRead(childComplexity), true

	case "User.subscribedColumns":
		if e.complexity.User.SubscribedColumns == nil {
			break
		}

		return e.complexity.User.SubscribedColumns(childComplexity), true

	case "UserSeedState.avatarUrl":
		if e.complexity.UserSeedState.AvatarURL == nil {
			break
		}

		return e.complexity.UserSeedState.AvatarURL(childComplexity), true

	case "UserSeedState.id":
		if e.complexity.UserSeedState.ID == nil {
			break
		}

		return e.complexity.UserSeedState.ID(childComplexity), true

	case "UserSeedState.name":
		if e.complexity.UserSeedState.Name == nil {
			break
		}

		return e.complexity.UserSeedState.Name(childComplexity), true

	case "UserState.user":
		if e.complexity.UserState.User == nil {
			break
		}

		return e.complexity.UserState.User(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddSubSourceInput,
		ec.unmarshalInputAddWeiboSubSourceInput,
		ec.unmarshalInputColumnRefreshInput,
		ec.unmarshalInputColumnSeedStateInput,
		ec.unmarshalInputColumnsGetPostsInput,
		ec.unmarshalInputCustomizedCrawlerPanopticConfigForm,
		ec.unmarshalInputCustomizedCrawlerParams,
		ec.unmarshalInputDeleteColumnInput,
		ec.unmarshalInputDeleteSubSourceInput,
		ec.unmarshalInputFeedRefreshInput,
		ec.unmarshalInputFeedSeedStateInput,
		ec.unmarshalInputFeedsGetPostsInput,
		ec.unmarshalInputNewPostInput,
		ec.unmarshalInputNewSourceInput,
		ec.unmarshalInputNewUserInput,
		ec.unmarshalInputNotificationSettingInput,
		ec.unmarshalInputPostInput,
		ec.unmarshalInputRefreshFilterInput,
		ec.unmarshalInputSearchPostsInput,
		ec.unmarshalInputSearchPostsRefreshInput,
		ec.unmarshalInputSeedStateInput,
		ec.unmarshalInputSetFeedFavoriteInput,
		ec.unmarshalInputSetItemsReadStatusInput,
		ec.unmarshalInputSourcesInput,
		ec.unmarshalInputSubscribeInput,
		ec.unmarshalInputSubsourcesInput,
		ec.unmarshalInputUpsertColumnInput,
		ec.unmarshalInputUpsertFeedInput,
		ec.unmarshalInputUpsertSubSourceInput,
		ec.unmarshalInputUserIdInput,
		ec.unmarshalInputUserSeedStateInput,
		ec.unmarshalInputUserStateInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../column.graphqls", Input: `type Column implements ColumnSeedStateInterface
  @goModel(model: "model.Column") {
  id: String!
  createdAt: Time!
  updatedAt: Time!
  creator: User
  name: String!
  subscribers: [User!]!
  feeds: [Feed!]!
  visibility: Visibility!
  # How many users are subscribing to this Column, used in sharedColumn.
  subscriberCount: Int
  mobileNotification: Boolean!
  readed: [String!]
  webNotification: Boolean!
  showUnreadIndicatorOnIcon: Boolean!
}

type ColumnSeedState implements ColumnSeedStateInterface {
  id: String!
  name: String!
}

input ColumnSeedStateInput {
  id: String!
  name: String!
}

interface ColumnSeedStateInterface {
  id: String!
  name: String!
}

type PostInColumnOutput {
  post: Post!
  cursor: Int!
}
`, BuiltIn: false},
	{Name: "../customizedCrawlerTest.graphqls", Input: `type CustomizedCrawlerTestResponse {
  baseHtml: String
  title: String
  content: String
  externalId: String
  time: String
  images: [String!]
  subsource: String
  originUrl: String
}
`, BuiltIn: false},
	{Name: "../directives.graphqls", Input: `# GQL Directives
# This part is fairly necessary and is described in the gql documentation
# https://gqlgen.com/config/
directive @goModel(model: String, models: [String!]) on OBJECT
    | INPUT_OBJECT
    | SCALAR
    | ENUM
    | INTERFACE
    | UNION

directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION
    | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../feed.graphqls", Input: `type Feed implements FeedSeedStateInterface @goModel(model: "model.Feed") {
  id: String!
  createdAt: Time!
  updatedAt: Time!
  creator: User
  name: String!
  posts: [Post!]!
  subSources: [SubSource!]!
  columns: [Column!]
  filterDataExpression: String!
  visibility: Visibility
}

type FeedSeedState implements FeedSeedStateInterface {
  id: String!
  name: String!
}

input FeedSeedStateInput {
  id: String!
  name: String!
}

interface FeedSeedStateInterface {
  id: String!
  name: String!
}

type PostInFeedOutput {
  post: Post!
  cursor: Int!
}
`, BuiltIn: false},
	{Name: "../post.graphqls", Input: `type Post @goModel(model: "model.Post") {
  id: String!
  createdAt: Time!
  deletedAt: Time
  title: String!
  content: String!
  subSource: SubSource!
  sharedFromPost: Post
  readByUser: [User!]!
  publishedFeeds: [Feed!]!
  cursor: Int!
  # urls to resources
  imageUrls: [String!]!
  fileUrls: [String!]!

  # Time when crawler finished crawling this post
  crawledAt: Time

  # url from where this post is crawled
  originUrl: String

  # actual time content is generated by 3rd party website
  contentGeneratedAt: Time

  # is the post shared by another post, if true, this post will not be published if it is not published
  inSharingChain: Boolean

  # deduplicate id is generated by crawler, purely depends on logic in crawler
  deduplicateId: String!

  semanticHashing: String
  embedding: [Float!]!

  # the parent post of this thread in chronological order, together with this
  # post they form a thread.
  replyThread: [Post!]!

  # tags indicating post content
  tags: [String!]!

  # indicating if the post has been read
  isRead: Boolean!

  # indicating if the post is delayed
  delayed: Boolean!
}
`, BuiltIn: false},
	{Name: "../schema.graphqls", Input: `# GraphQL schema

enum FeedRefreshDirection {
  NEW
  OLD
}

enum Visibility {
  GLOBAL
  PRIVATE
}

enum ItemType {
  POST
  DUPLICATION
}

input SourcesInput {
  subSourceFromSharedPost: Boolean!
}

input SubsourcesInput {
  isFromSharedPost: Boolean!
  isCustomized: Boolean
}

input PostInput {
  id: String!
}

input NewUserInput {
  id: String!
  name: String!
}

# TODO(BONING): deprecate visibility
input UpsertFeedInput {
  columnId: String
  userId: String!
  feedId: String
  name: String!
  filterDataExpression: String!
  subSourceIds: [String!]!
  addToColumn: Boolean!
}

# TODO(BONING): we shouldn't need to edit feeds in this input?
input UpsertColumnInput {
  columnId: String
  userId: String!
  name: String!
  visibility: Visibility!
  feedIds: [String!]
}

# TODO: for testing purpose, real post is created by crawler and publisher
input NewPostInput {
  title: String!
  content: String!
  subSourceId: String!
  feedsIdPublishTo: [String!]
  sharedFromPostId: String
}

input SubscribeInput {
  userId: String!
  columnId: String!
}

input NotificationSettingInput {
  userId: String!
  columnId: String!
  mobile: Boolean!
  web: Boolean!
  unreadIndicatorOnIcon: Boolean!
}

input NewSourceInput {
  userId: String!
  name: String!
  domain: String!
  customizedCrawlerPanopticConfigForm: CustomizedCrawlerPanopticConfigForm
}

# This schema has all information needed to construct a PanopticConfig in panoptic_config.proto
# data_collector_id is predefined to be COLLECTOR_USER_CUSTOMIZED_SOURCE
input CustomizedCrawlerPanopticConfigForm {
  name: String # name of the config if not specified, use source name
  # for TaskSchedule:
  startImmediately: Boolean # default to true
  scheduleEveryMilliseconds: Int # default to 5 minutes
  # for CustomizedCrawlerParams
  customizedCrawlerParams: CustomizedCrawlerParams!
}

# This schema has all information needed to construct a CustomizedCrawlerParams in panoptic.proto
input CustomizedCrawlerParams {
  crawlUrl: String! # url to crawl, e.g. https://www.cls.cn/telegraph
  baseSelector: String! # base selector should return a list of DOM elements where each one corresponds to a single post
  titleRelativeSelector: String # relative selector to the base selector
  contentRelativeSelector: String
  externalIdRelativeSelector: String
  timeRelativeSelector: String #if not specified, use the cralwed time as content generated time
  imageRelativeSelector: String
  subsourceRelativeSelector: String #how to deal with subsource spec
  originUrlRelativeSelector: String #by default is the url
  originUrlIsRelativePath: Boolean #if the originUrlRelativeSelector generates relative path to crawlUrl
}

# isFromSharedPost = true means the subsource is not for cralwing
# it is from a shared post
# example: when subsource is an owner of a post in a retweet post
input UpsertSubSourceInput {
  # disable subsource id, use name + source id to identify
  # subSourceId: String
  name: String!
  externalIdentifier: String!
  sourceId: String!
  avatarUrl: String!
  originUrl: String!
  isFromSharedPost: Boolean!

  # use this to customize crawler behavior, the source should have
  # collector_id = COLLECTOR_USER_CUSTOMIZED_SUBSOURCE in config
  customizedCrawlerParams: CustomizedCrawlerParams
}

input DeleteSubSourceInput {
  subsourceId: String!
}

# Add weibo user to the database for panoptic to crawl
input AddWeiboSubSourceInput {
  name: String!
}

input AddSubSourceInput {
  # SourceId to which this subSource belongs to.
  sourceId: String!
  # subSourceUserName is the actual username for a given Source.
  subSourceUserName: String!
}

input FeedRefreshInput {
  feedId: String!
  limit: Int!
  cursor: Int!
  direction: FeedRefreshDirection!
  feedUpdatedTime: Time
  query: String
  filter: RefreshFilterInput
}

input RefreshFilterInput {
  unread: Boolean
}

input ColumnRefreshInput {
  columnId: String!
  limit: Int!
  direction: FeedRefreshDirection!
  cursor: Int!
  otherEndCursor: Int

  feedIds: [String!]!
  feedUpdatedTimes: [Time]
  columnUpdatedTime: Time
  query: String
  filter: RefreshFilterInput
}

input SearchPostsRefreshInput {
  limit: Int!
  direction: FeedRefreshDirection!
  cursor: Int!
  otherEndCursor: Int
  query: String
  filter: RefreshFilterInput
}

input SearchPostsInput {
  userId: String!
  searchPostsRefreshInput: SearchPostsRefreshInput!
}

input FeedsGetPostsInput {
  userId: String!
  feedRefreshInputs: [FeedRefreshInput!]!
}

input ColumnsGetPostsInput {
  userId: String!
  columnsRefreshInputs: [ColumnRefreshInput!]!
}

input UserIdInput {
  userId: String!
}

input DeleteColumnInput {
  userId: String!
  columnId: String!
}

input SetItemsReadStatusInput {
  userId: String!
  itemNodeIds: [String!]!
  read: Boolean!
  type: ItemType!
}

input SetFeedFavoriteInput {
  userId: String!
  feedId: String!
  isFavorite: Boolean!
}

type Query {
  allVisibleColumns: [Column!]
  favoriteFeeds(input: UserIdInput): [Feed!]
  post(input: PostInput): Post!
  posts(input: SearchPostsInput): [Post!]!
  users: [User!]

  # postsReadStatus(input: GetPostsReadStatusInput!): [Boolean!]!
  # State is the main API to "bootstrap" application, where it fetches required
  # states for the given input. After receiving the StateOutput, client will
  # then make subsequent calls to request all data.
  userState(input: UserStateInput!): UserState!

  # Feeds is the main API for newsfeed
  # WARNING: if you do not pass feedUpdatedTime, your curosr/direction will be ignored
  # WARNING: please pass the cursor based on returned posts cursor, otherwise the republish will skip some posts

  # It is used to return posts for a feed
  # It can be called with a list of following queries, each query represent a feed
  # Caller can specify only 1 or more feeds

  # FeedID          string					Feed id to fetch posts
  # Limit           int						Max amount of posts shall the API return, at most 30
  # Cursor          int						The cursor of the pivot post
  # Direction       FeedRefreshDirection	NEW or OLD description below
  # FeedUpdatedTime *time.Time				Time stamp used to represent feed version description below

  # Returns: Feeds
  # 	caller can get each feed's FeedUpdatedTime and its posts, and each post has a cursor

  # How to use cursor and direction?
  # 	Direction = NEW:    load feed new posts with cursor larger than cursor A (default -1), from newest one, no more than Limit
  # 	Direction = OLD: load feed old posts with cursor smaller than cursor B (default -1), from newest one, no more than Limit

  # 	If not specified, use NEW as direction, -1 as cursor to give newest Posts

  # 	How is cursor defined:
  # 		it is an auto-increament index Posts

  # What if feed is changed, and front end doesn't know?
  # Feed updates are not pushed to frontend, backend pass a turn-around field FeedUpdatedTime
  # 	to frontend, and API call will carry this timestamp. Once feed is updated, API will know the
  # 	input timestamp is not same as the updated "FeedUpdatedTime", thus, will not respect the cursor

  # If frontend disconnected for a while, how do front end know it gets all posts up until latest?
  # In this case, front end can still query {Feeds} with its stored NEWest cursor
  # 	{Feeds} will return the most recent N post up to N=Limit
  # 	Front end can check if the N == Limit, if so, it indicate there is very likely to be more posts
  # 	need to be fetched. And frontend can send another {Feeds} request. It can also choose not
  # 	to fetch so many posts.

  # What if the data expression filter or subsource are changed
  # Chaging feed is on {upsertFeed}
  # For {feeds} we will handle on-the-fly posts re-publish, in these conditions:
  # 1. query OLD but can't satisfy the limit
  feeds(input: FeedsGetPostsInput): [Feed!]!
  columns(input: ColumnsGetPostsInput): [Column!]!

  subSources(input: SubsourcesInput): [SubSource!]!
  sources(input: SourcesInput): [Source!]

  tryCustomizedCrawler(
    input: CustomizedCrawlerParams
  ): [CustomizedCrawlerTestResponse!]
}

type Mutation {
  createUser(input: NewUserInput!): User!
  upsertFeed(input: UpsertFeedInput!): Feed!
  upsertColumn(input: UpsertColumnInput!): Column!
  deleteColumn(input: DeleteColumnInput!): Column!

  # TODO: for testing purpose, real post is created by crawler and publisher
  createPost(input: NewPostInput!): Post!
  # TODO: what should be a better output
  subscribe(input: SubscribeInput!): User!

  createSource(input: NewSourceInput!): Source!
  upsertSubSource(input: UpsertSubSourceInput!): SubSource!

  # Deprecated!
  # TODO(chenweilunster): Remove this function and all its existence.
  addWeiboSubSource(input: AddWeiboSubSourceInput!): SubSource!

  # For now, addSubSource is used when frontend wants to add some more
  # subSources for a given source (e.g. Weibo, Twitter). It should validate the
  # input, store the normalized version, and return the error code if any.
  # This mutation isn't intended to be used as a generic AddSubSource method for
  # now, but it can be extended to be a generic one.
  addSubSource(input: AddSubSourceInput!): SubSource!
  deleteSubSource(input: DeleteSubSourceInput): SubSource!

  syncUp(input: SeedStateInput): SeedState

  setItemsReadStatus(input: SetItemsReadStatusInput!): Boolean!
  setFeedFavorite(input: SetFeedFavoriteInput!): Boolean!

  setNotificationSetting(input: NotificationSettingInput!): Boolean!
}

type Subscription {
  # Subscribe to signals sending from server side. Client side should handle
  # signals properly. The first time this is called will always return
  # SEEDSTATE signal.
  signal(userId: String!): Signal!
}

scalar Time
`, BuiltIn: false},
	{Name: "../seedState.graphqls", Input: `type SeedState @goModel(model: "model.SeedState") {
  userSeedState: UserSeedState!
  columnSeedState: [ColumnSeedState!]!
}

input SeedStateInput {
  userSeedState: UserSeedStateInput!
  columnSeedState: [ColumnSeedStateInput!]!
}
`, BuiltIn: false},
	{Name: "../signal.graphqls", Input: `# Each SignalType instruct the client side application to do some certain thing.
enum SignalType {
  # Instruct client side to pull seed state. This is the first signal send to
  # client side application.
  SEED_STATE
  SET_ITEMS_READ_STATUS
}

type Signal @goModel(model: "model.Signal") {
  signalType: SignalType!

  # sigalPayload is a general payload, and each type of signal needs to parse its own payload
  # the parser should be added to signal_payload.go
  signalPayload: String

  # Some signal also need params, adding all custom params below this line.
}
`, BuiltIn: false},
	{Name: "../source.graphqls", Input: `type Source @goModel(model: "model.Source") {
  id: String!
  createdAt: Time!
  deletedAt: Time
  creator: User
  name: String!
  domain: String
  subsources: [SubSource!]!
}
`, BuiltIn: false},
	{Name: "../subsource.graphqls", Input: `type SubSource @goModel(model: "model.SubSource") {
  id: String!
  createdAt: Time!
  deletedAt: Time
  name: String!
  externalIdentifier: String!
  source: Source!
  avatarUrl: String!
  originUrl: String!
  isFromSharedPost: Boolean!
  customizedCrawlerParams: String
}
`, BuiltIn: false},
	{Name: "../user.graphqls", Input: `type User implements UserSeedStateInterface @goModel(model: "model.User") {
  id: String!
  createdAt: Time!
  deletedAt: Time
  name: String!
  avatarUrl: String!
  subscribedColumns: [Column!]!
  postsRead: [Post!]
}

type UserSeedState implements UserSeedStateInterface {
  id: String!
  name: String!
  avatarUrl: String!
}

input UserSeedStateInput {
  id: String!
  name: String!
  avatarUrl: String!
}

interface UserSeedStateInterface {
  id: String!
  name: String!
  avatarUrl: String!
}
`, BuiltIn: false},
	{Name: "../userState.graphqls", Input: `input UserStateInput {
  userId: String!
}

type UserState @goModel(model: "model.UserState") {
  user: User
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addSubSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AddSubSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddSubSourceInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐAddSubSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addWeiboSubSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AddWeiboSubSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddWeiboSubSourceInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐAddWeiboSubSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewPostInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNewPostInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐNewPostInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNewSourceInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐNewSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNewUserInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐNewUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteColumn_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DeleteColumnInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteColumnInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐDeleteColumnInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSubSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.DeleteSubSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteSubSourceInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐDeleteSubSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setFeedFavorite_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SetFeedFavoriteInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSetFeedFavoriteInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSetFeedFavoriteInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setItemsReadStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SetItemsReadStatusInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSetItemsReadStatusInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSetItemsReadStatusInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setNotificationSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NotificationSettingInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNotificationSettingInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐNotificationSettingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_subscribe_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SubscribeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSubscribeInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubscribeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_syncUp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SeedStateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOSeedStateInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSeedStateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertColumn_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpsertColumnInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertColumnInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUpsertColumnInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertFeed_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpsertFeedInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertFeedInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUpsertFeedInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertSubSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpsertSubSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertSubSourceInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUpsertSubSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_columns_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ColumnsGetPostsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOColumnsGetPostsInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnsGetPostsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_favoriteFeeds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.UserIDInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUserIdInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserIDInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_feeds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.FeedsGetPostsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOFeedsGetPostsInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedsGetPostsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_post_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PostInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOPostInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPostInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_posts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SearchPostsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOSearchPostsInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSearchPostsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SourcesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOSourcesInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSourcesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_subSources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SubsourcesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOSubsourcesInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubsourcesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tryCustomizedCrawler_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.CustomizedCrawlerParams
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCustomizedCrawlerParams2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerParams(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userState_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UserStateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUserStateInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserStateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_signal_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Column_id(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_creator(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.User)
	fc.Result = res
	return ec.marshalOUser2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_name(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_subscribers(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_subscribers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscribers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_subscribers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_feeds(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_feeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Feeds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_feeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_visibility(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Visibility)
	fc.Result = res
	return ec.marshalNVisibility2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐVisibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Visibility does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_subscriberCount(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_subscriberCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Column().SubscriberCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_subscriberCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_mobileNotification(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_mobileNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Column().MobileNotification(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_mobileNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_readed(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_readed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Readed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_readed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_webNotification(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_webNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Column().WebNotification(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_webNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_showUnreadIndicatorOnIcon(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Column().ShowUnreadIndicatorOnIcon(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_showUnreadIndicatorOnIcon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ColumnSeedState_id(ctx context.Context, field graphql.CollectedField, obj *model.ColumnSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ColumnSeedState_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ColumnSeedState_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ColumnSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ColumnSeedState_name(ctx context.Context, field graphql.CollectedField, obj *model.ColumnSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ColumnSeedState_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ColumnSeedState_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ColumnSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_baseHtml(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_baseHtml(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseHTML, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_baseHtml(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_title(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_content(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_externalId(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_externalId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_externalId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_time(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_images(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Images, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_images(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_subsource(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_subsource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subsource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_subsource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_originUrl(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_originUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OriginURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_originUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_id(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_creator(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.User)
	fc.Result = res
	return ec.marshalOUser2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_name(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_posts(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Posts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalNPost2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_subSources(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_subSources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubSources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSourceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_subSources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_columns(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_columns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Columns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Column)
	fc.Result = res
	return ec.marshalOColumn2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_columns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_filterDataExpression(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_filterDataExpression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().FilterDataExpression(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_filterDataExpression(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_visibility(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Visibility)
	fc.Result = res
	return ec.marshalOVisibility2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐVisibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Visibility does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedSeedState_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedSeedState_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedSeedState_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedSeedState_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedSeedState_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedSeedState_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["input"].(model.NewUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertFeed(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertFeed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertFeed(rctx, fc.Args["input"].(model.UpsertFeedInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertFeed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertFeed_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertColumn(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertColumn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertColumn(rctx, fc.Args["input"].(model.UpsertColumnInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Column)
	fc.Result = res
	return ec.marshalNColumn2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumn(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertColumn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertColumn_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteColumn(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteColumn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteColumn(rctx, fc.Args["input"].(model.DeleteColumnInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Column)
	fc.Result = res
	return ec.marshalNColumn2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumn(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteColumn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteColumn_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePost(rctx, fc.Args["input"].(model.NewPostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalNPost2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_subscribe(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_subscribe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Subscribe(rctx, fc.Args["input"].(model.SubscribeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_subscribe(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_subscribe_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSource(rctx, fc.Args["input"].(model.NewSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Source)
	fc.Result = res
	return ec.marshalNSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Source_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Source_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Source_deletedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Source_creator(ctx, field)
			case "name":
				return ec.fieldContext_Source_name(ctx, field)
			case "domain":
				return ec.fieldContext_Source_domain(ctx, field)
			case "subsources":
				return ec.fieldContext_Source_subsources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertSubSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertSubSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertSubSource(rctx, fc.Args["input"].(model.UpsertSubSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertSubSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertSubSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addWeiboSubSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addWeiboSubSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddWeiboSubSource(rctx, fc.Args["input"].(model.AddWeiboSubSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addWeiboSubSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addWeiboSubSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addSubSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addSubSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddSubSource(rctx, fc.Args["input"].(model.AddSubSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addSubSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addSubSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSubSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSubSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSubSource(rctx, fc.Args["input"].(*model.DeleteSubSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSubSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSubSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_syncUp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_syncUp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SyncUp(rctx, fc.Args["input"].(*model.SeedStateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SeedState)
	fc.Result = res
	return ec.marshalOSeedState2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSeedState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_syncUp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userSeedState":
				return ec.fieldContext_SeedState_userSeedState(ctx, field)
			case "columnSeedState":
				return ec.fieldContext_SeedState_columnSeedState(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SeedState", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_syncUp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setItemsReadStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setItemsReadStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetItemsReadStatus(rctx, fc.Args["input"].(model.SetItemsReadStatusInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setItemsReadStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setItemsReadStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setFeedFavorite(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setFeedFavorite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetFeedFavorite(rctx, fc.Args["input"].(model.SetFeedFavoriteInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setFeedFavorite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setFeedFavorite_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setNotificationSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setNotificationSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetNotificationSetting(rctx, fc.Args["input"].(model.NotificationSettingInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setNotificationSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setNotificationSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Post_id(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_title(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_content(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_subSource(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_subSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubSource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_subSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_sharedFromPost(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_sharedFromPost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SharedFromPost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalOPost2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_sharedFromPost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_readByUser(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_readByUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReadByUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_readByUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_publishedFeeds(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_publishedFeeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublishedFeeds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_publishedFeeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_cursor(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_imageUrls(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_imageUrls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().ImageUrls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_imageUrls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_fileUrls(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_fileUrls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().FileUrls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_fileUrls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_crawledAt(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_crawledAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CrawledAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_crawledAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_originUrl(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_originUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OriginUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_originUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_contentGeneratedAt(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_contentGeneratedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentGeneratedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_contentGeneratedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_inSharingChain(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_inSharingChain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InSharingChain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_inSharingChain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_deduplicateId(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_deduplicateId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeduplicateId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_deduplicateId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_semanticHashing(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_semanticHashing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SemanticHashing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_semanticHashing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_embedding(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_embedding(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().Embedding(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]float64)
	fc.Result = res
	return ec.marshalNFloat2ᚕfloat64ᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_embedding(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_replyThread(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_replyThread(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReplyThread, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalNPost2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_replyThread(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_tags(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_isRead(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_isRead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRead, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_isRead(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_delayed(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_delayed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Delayed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_delayed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostInColumnOutput_post(ctx context.Context, field graphql.CollectedField, obj *model.PostInColumnOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostInColumnOutput_post(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Post, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalNPost2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostInColumnOutput_post(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostInColumnOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostInColumnOutput_cursor(ctx context.Context, field graphql.CollectedField, obj *model.PostInColumnOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostInColumnOutput_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostInColumnOutput_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostInColumnOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostInFeedOutput_post(ctx context.Context, field graphql.CollectedField, obj *model.PostInFeedOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostInFeedOutput_post(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Post, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalNPost2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostInFeedOutput_post(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostInFeedOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostInFeedOutput_cursor(ctx context.Context, field graphql.CollectedField, obj *model.PostInFeedOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostInFeedOutput_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostInFeedOutput_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostInFeedOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_allVisibleColumns(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_allVisibleColumns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllVisibleColumns(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Column)
	fc.Result = res
	return ec.marshalOColumn2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_allVisibleColumns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_favoriteFeeds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_favoriteFeeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FavoriteFeeds(rctx, fc.Args["input"].(*model.UserIDInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalOFeed2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_favoriteFeeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_favoriteFeeds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_post(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_post(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Post(rctx, fc.Args["input"].(*model.PostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalNPost2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_post(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_post_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_posts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Posts(rctx, fc.Args["input"].(*model.SearchPostsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalNPost2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_posts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_userState(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserState(rctx, fc.Args["input"].(model.UserStateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserState)
	fc.Result = res
	return ec.marshalNUserState2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserState_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserState", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userState_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_feeds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_feeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Feeds(rctx, fc.Args["input"].(*model.FeedsGetPostsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_feeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_feeds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_columns(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_columns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Columns(rctx, fc.Args["input"].(*model.ColumnsGetPostsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Column)
	fc.Result = res
	return ec.marshalNColumn2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_columns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_columns_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_subSources(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_subSources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SubSources(rctx, fc.Args["input"].(*model.SubsourcesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSourceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_subSources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_subSources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sources(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_sources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Sources(rctx, fc.Args["input"].(*model.SourcesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Source)
	fc.Result = res
	return ec.marshalOSource2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSourceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_sources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Source_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Source_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Source_deletedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Source_creator(ctx, field)
			case "name":
				return ec.fieldContext_Source_name(ctx, field)
			case "domain":
				return ec.fieldContext_Source_domain(ctx, field)
			case "subsources":
				return ec.fieldContext_Source_subsources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tryCustomizedCrawler(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tryCustomizedCrawler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TryCustomizedCrawler(rctx, fc.Args["input"].(*model.CustomizedCrawlerParams))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CustomizedCrawlerTestResponse)
	fc.Result = res
	return ec.marshalOCustomizedCrawlerTestResponse2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerTestResponseᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tryCustomizedCrawler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "baseHtml":
				return ec.fieldContext_CustomizedCrawlerTestResponse_baseHtml(ctx, field)
			case "title":
				return ec.fieldContext_CustomizedCrawlerTestResponse_title(ctx, field)
			case "content":
				return ec.fieldContext_CustomizedCrawlerTestResponse_content(ctx, field)
			case "externalId":
				return ec.fieldContext_CustomizedCrawlerTestResponse_externalId(ctx, field)
			case "time":
				return ec.fieldContext_CustomizedCrawlerTestResponse_time(ctx, field)
			case "images":
				return ec.fieldContext_CustomizedCrawlerTestResponse_images(ctx, field)
			case "subsource":
				return ec.fieldContext_CustomizedCrawlerTestResponse_subsource(ctx, field)
			case "originUrl":
				return ec.fieldContext_CustomizedCrawlerTestResponse_originUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomizedCrawlerTestResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tryCustomizedCrawler_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeedState_userSeedState(ctx context.Context, field graphql.CollectedField, obj *model.SeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeedState_userSeedState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSeedState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserSeedState)
	fc.Result = res
	return ec.marshalNUserSeedState2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserSeedState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeedState_userSeedState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserSeedState_id(ctx, field)
			case "name":
				return ec.fieldContext_UserSeedState_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_UserSeedState_avatarUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSeedState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeedState_columnSeedState(ctx context.Context, field graphql.CollectedField, obj *model.SeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeedState_columnSeedState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColumnSeedState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ColumnSeedState)
	fc.Result = res
	return ec.marshalNColumnSeedState2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnSeedStateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeedState_columnSeedState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ColumnSeedState_id(ctx, field)
			case "name":
				return ec.fieldContext_ColumnSeedState_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ColumnSeedState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signal_signalType(ctx context.Context, field graphql.CollectedField, obj *model.Signal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signal_signalType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignalType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SignalType)
	fc.Result = res
	return ec.marshalNSignalType2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSignalType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signal_signalType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SignalType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signal_signalPayload(ctx context.Context, field graphql.CollectedField, obj *model.Signal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signal_signalPayload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignalPayload, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signal_signalPayload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_id(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Source().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_creator(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.User)
	fc.Result = res
	return ec.marshalOUser2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_name(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_domain(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_domain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_domain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_subsources(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_subsources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubSources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2ᚕgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSourceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_subsources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_id(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SubSource().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_name(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_externalIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_externalIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_externalIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_source(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SubSource().Source(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Source)
	fc.Result = res
	return ec.marshalNSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Source_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Source_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Source_deletedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Source_creator(ctx, field)
			case "name":
				return ec.fieldContext_Source_name(ctx, field)
			case "domain":
				return ec.fieldContext_Source_domain(ctx, field)
			case "subsources":
				return ec.fieldContext_Source_subsources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_avatarUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_originUrl(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_originUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OriginUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_originUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_isFromSharedPost(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsFromSharedPost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_isFromSharedPost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_customizedCrawlerParams(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CustomizedCrawlerParams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_customizedCrawlerParams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_signal(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_signal(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Signal(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Signal):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNSignal2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSignal(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_signal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "signalType":
				return ec.fieldContext_Signal_signalType(ctx, field)
			case "signalPayload":
				return ec.fieldContext_Signal_signalPayload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Signal", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_signal_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_avatarUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_subscribedColumns(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_subscribedColumns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscribedColumns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Column)
	fc.Result = res
	return ec.marshalNColumn2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_subscribedColumns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_postsRead(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_postsRead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostsRead, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalOPost2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_postsRead(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSeedState_id(ctx context.Context, field graphql.CollectedField, obj *model.UserSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSeedState_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSeedState_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSeedState_name(ctx context.Context, field graphql.CollectedField, obj *model.UserSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSeedState_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSeedState_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSeedState_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *model.UserSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSeedState_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSeedState_avatarUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserState_user(ctx context.Context, field graphql.CollectedField, obj *model.UserState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserState_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserState_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddSubSourceInput(ctx context.Context, obj interface{}) (model.AddSubSourceInput, error) {
	var it model.AddSubSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sourceId", "subSourceUserName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceID = data
		case "subSourceUserName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subSourceUserName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubSourceUserName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddWeiboSubSourceInput(ctx context.Context, obj interface{}) (model.AddWeiboSubSourceInput, error) {
	var it model.AddWeiboSubSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputColumnRefreshInput(ctx context.Context, obj interface{}) (model.ColumnRefreshInput, error) {
	var it model.ColumnRefreshInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"columnId", "limit", "direction", "cursor", "otherEndCursor", "feedIds", "feedUpdatedTimes", "columnUpdatedTime", "query", "filter"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNFeedRefreshDirection2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedRefreshDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "cursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursor"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cursor = data
		case "otherEndCursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("otherEndCursor"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OtherEndCursor = data
		case "feedIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedIds = data
		case "feedUpdatedTimes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedUpdatedTimes"))
			data, err := ec.unmarshalOTime2ᚕᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedUpdatedTimes = data
		case "columnUpdatedTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnUpdatedTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnUpdatedTime = data
		case "query":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			data, err := ec.unmarshalORefreshFilterInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐRefreshFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filter = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputColumnSeedStateInput(ctx context.Context, obj interface{}) (model.ColumnSeedStateInput, error) {
	var it model.ColumnSeedStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputColumnsGetPostsInput(ctx context.Context, obj interface{}) (model.ColumnsGetPostsInput, error) {
	var it model.ColumnsGetPostsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "columnsRefreshInputs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "columnsRefreshInputs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnsRefreshInputs"))
			data, err := ec.unmarshalNColumnRefreshInput2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnRefreshInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnsRefreshInputs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCustomizedCrawlerPanopticConfigForm(ctx context.Context, obj interface{}) (model.CustomizedCrawlerPanopticConfigForm, error) {
	var it model.CustomizedCrawlerPanopticConfigForm
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "startImmediately", "scheduleEveryMilliseconds", "customizedCrawlerParams"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "startImmediately":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startImmediately"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartImmediately = data
		case "scheduleEveryMilliseconds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scheduleEveryMilliseconds"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScheduleEveryMilliseconds = data
		case "customizedCrawlerParams":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("customizedCrawlerParams"))
			data, err := ec.unmarshalNCustomizedCrawlerParams2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CustomizedCrawlerParams = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCustomizedCrawlerParams(ctx context.Context, obj interface{}) (model.CustomizedCrawlerParams, error) {
	var it model.CustomizedCrawlerParams
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"crawlUrl", "baseSelector", "titleRelativeSelector", "contentRelativeSelector", "externalIdRelativeSelector", "timeRelativeSelector", "imageRelativeSelector", "subsourceRelativeSelector", "originUrlRelativeSelector", "originUrlIsRelativePath"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "crawlUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("crawlUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CrawlURL = data
		case "baseSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseSelector"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseSelector = data
		case "titleRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleRelativeSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleRelativeSelector = data
		case "contentRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentRelativeSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContentRelativeSelector = data
		case "externalIdRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalIdRelativeSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalIDRelativeSelector = data
		case "timeRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeRelativeSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeRelativeSelector = data
		case "imageRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageRelativeSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageRelativeSelector = data
		case "subsourceRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subsourceRelativeSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubsourceRelativeSelector = data
		case "originUrlRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("originUrlRelativeSelector"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.OriginURLRelativeSelector = data
		case "originUrlIsRelativePath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("originUrlIsRelativePath"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OriginURLIsRelativePath = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteColumnInput(ctx context.Context, obj interface{}) (model.DeleteColumnInput, error) {
	var it model.DeleteColumnInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "columnId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteSubSourceInput(ctx context.Context, obj interface{}) (model.DeleteSubSourceInput, error) {
	var it model.DeleteSubSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subsourceId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subsourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subsourceId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubsourceID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedRefreshInput(ctx context.Context, obj interface{}) (model.FeedRefreshInput, error) {
	var it model.FeedRefreshInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"feedId", "limit", "cursor", "direction", "feedUpdatedTime", "query", "filter"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "feedId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedID = data
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "cursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursor"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cursor = data
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNFeedRefreshDirection2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedRefreshDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "feedUpdatedTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedUpdatedTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedUpdatedTime = data
		case "query":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			data, err := ec.unmarshalORefreshFilterInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐRefreshFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filter = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedSeedStateInput(ctx context.Context, obj interface{}) (model.FeedSeedStateInput, error) {
	var it model.FeedSeedStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedsGetPostsInput(ctx context.Context, obj interface{}) (model.FeedsGetPostsInput, error) {
	var it model.FeedsGetPostsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "feedRefreshInputs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "feedRefreshInputs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedRefreshInputs"))
			data, err := ec.unmarshalNFeedRefreshInput2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedRefreshInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedRefreshInputs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewPostInput(ctx context.Context, obj interface{}) (model.NewPostInput, error) {
	var it model.NewPostInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "content", "subSourceId", "feedsIdPublishTo", "sharedFromPostId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "content":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("content"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Content = data
		case "subSourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subSourceId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubSourceID = data
		case "feedsIdPublishTo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedsIdPublishTo"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedsIDPublishTo = data
		case "sharedFromPostId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sharedFromPostId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SharedFromPostID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewSourceInput(ctx context.Context, obj interface{}) (model.NewSourceInput, error) {
	var it model.NewSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "name", "domain", "customizedCrawlerPanopticConfigForm"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "domain":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domain"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Domain = data
		case "customizedCrawlerPanopticConfigForm":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("customizedCrawlerPanopticConfigForm"))
			data, err := ec.unmarshalOCustomizedCrawlerPanopticConfigForm2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerPanopticConfigForm(ctx, v)
			if err != nil {
				return it, err
			}
			it.CustomizedCrawlerPanopticConfigForm = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewUserInput(ctx context.Context, obj interface{}) (model.NewUserInput, error) {
	var it model.NewUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationSettingInput(ctx context.Context, obj interface{}) (model.NotificationSettingInput, error) {
	var it model.NotificationSettingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "columnId", "mobile", "web", "unreadIndicatorOnIcon"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		case "mobile":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobile"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mobile = data
		case "web":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("web"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Web = data
		case "unreadIndicatorOnIcon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unreadIndicatorOnIcon"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnreadIndicatorOnIcon = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPostInput(ctx context.Context, obj interface{}) (model.PostInput, error) {
	var it model.PostInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRefreshFilterInput(ctx context.Context, obj interface{}) (model.RefreshFilterInput, error) {
	var it model.RefreshFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"unread"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "unread":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unread"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Unread = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchPostsInput(ctx context.Context, obj interface{}) (model.SearchPostsInput, error) {
	var it model.SearchPostsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "searchPostsRefreshInput"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "searchPostsRefreshInput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchPostsRefreshInput"))
			data, err := ec.unmarshalNSearchPostsRefreshInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSearchPostsRefreshInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.SearchPostsRefreshInput = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchPostsRefreshInput(ctx context.Context, obj interface{}) (model.SearchPostsRefreshInput, error) {
	var it model.SearchPostsRefreshInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"limit", "direction", "cursor", "otherEndCursor", "query", "filter"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNFeedRefreshDirection2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedRefreshDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "cursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursor"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cursor = data
		case "otherEndCursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("otherEndCursor"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OtherEndCursor = data
		case "query":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			data, err := ec.unmarshalORefreshFilterInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐRefreshFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filter = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSeedStateInput(ctx context.Context, obj interface{}) (model.SeedStateInput, error) {
	var it model.SeedStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userSeedState", "columnSeedState"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userSeedState":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userSeedState"))
			data, err := ec.unmarshalNUserSeedStateInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserSeedStateInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserSeedState = data
		case "columnSeedState":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnSeedState"))
			data, err := ec.unmarshalNColumnSeedStateInput2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnSeedStateInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnSeedState = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetFeedFavoriteInput(ctx context.Context, obj interface{}) (model.SetFeedFavoriteInput, error) {
	var it model.SetFeedFavoriteInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "feedId", "isFavorite"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "feedId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedID = data
		case "isFavorite":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isFavorite"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsFavorite = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetItemsReadStatusInput(ctx context.Context, obj interface{}) (model.SetItemsReadStatusInput, error) {
	var it model.SetItemsReadStatusInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "itemNodeIds", "read", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "itemNodeIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemNodeIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemNodeIds = data
		case "read":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("read"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Read = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNItemType2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐItemType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourcesInput(ctx context.Context, obj interface{}) (model.SourcesInput, error) {
	var it model.SourcesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subSourceFromSharedPost"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subSourceFromSharedPost":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subSourceFromSharedPost"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubSourceFromSharedPost = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscribeInput(ctx context.Context, obj interface{}) (model.SubscribeInput, error) {
	var it model.SubscribeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "columnId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubsourcesInput(ctx context.Context, obj interface{}) (model.SubsourcesInput, error) {
	var it model.SubsourcesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"isFromSharedPost", "isCustomized"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "isFromSharedPost":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isFromSharedPost"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsFromSharedPost = data
		case "isCustomized":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isCustomized"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsCustomized = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertColumnInput(ctx context.Context, obj interface{}) (model.UpsertColumnInput, error) {
	var it model.UpsertColumnInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"columnId", "userId", "name", "visibility", "feedIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "visibility":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibility"))
			data, err := ec.unmarshalNVisibility2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐVisibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.Visibility = data
		case "feedIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedIds"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertFeedInput(ctx context.Context, obj interface{}) (model.UpsertFeedInput, error) {
	var it model.UpsertFeedInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"columnId", "userId", "feedId", "name", "filterDataExpression", "subSourceIds", "addToColumn"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "feedId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "filterDataExpression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filterDataExpression"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FilterDataExpression = data
		case "subSourceIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subSourceIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubSourceIds = data
		case "addToColumn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addToColumn"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddToColumn = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertSubSourceInput(ctx context.Context, obj interface{}) (model.UpsertSubSourceInput, error) {
	var it model.UpsertSubSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "externalIdentifier", "sourceId", "avatarUrl", "originUrl", "isFromSharedPost", "customizedCrawlerParams"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "externalIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalIdentifier = data
		case "sourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceID = data
		case "avatarUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarURL = data
		case "originUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("originUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OriginURL = data
		case "isFromSharedPost":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isFromSharedPost"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsFromSharedPost = data
		case "customizedCrawlerParams":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("customizedCrawlerParams"))
			data, err := ec.unmarshalOCustomizedCrawlerParams2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CustomizedCrawlerParams = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserIdInput(ctx context.Context, obj interface{}) (model.UserIDInput, error) {
	var it model.UserIDInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserSeedStateInput(ctx context.Context, obj interface{}) (model.UserSeedStateInput, error) {
	var it model.UserSeedStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "avatarUrl"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "avatarUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarURL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserStateInput(ctx context.Context, obj interface{}) (model.UserStateInput, error) {
	var it model.UserStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ColumnSeedStateInterface(ctx context.Context, sel ast.SelectionSet, obj model.ColumnSeedStateInterface) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Column:
		return ec._Column(ctx, sel, &obj)
	case *model.Column:
		if obj == nil {
			return graphql.Null
		}
		return ec._Column(ctx, sel, obj)
	case model.ColumnSeedState:
		return ec._ColumnSeedState(ctx, sel, &obj)
	case *model.ColumnSeedState:
		if obj == nil {
			return graphql.Null
		}
		return ec._ColumnSeedState(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _FeedSeedStateInterface(ctx context.Context, sel ast.SelectionSet, obj model.FeedSeedStateInterface) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Feed:
		return ec._Feed(ctx, sel, &obj)
	case *model.Feed:
		if obj == nil {
			return graphql.Null
		}
		return ec._Feed(ctx, sel, obj)
	case model.FeedSeedState:
		return ec._FeedSeedState(ctx, sel, &obj)
	case *model.FeedSeedState:
		if obj == nil {
			return graphql.Null
		}
		return ec._FeedSeedState(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UserSeedStateInterface(ctx context.Context, sel ast.SelectionSet, obj model.UserSeedStateInterface) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.User:
		return ec._User(ctx, sel, &obj)
	case *model.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case model.UserSeedState:
		return ec._UserSeedState(ctx, sel, &obj)
	case *model.UserSeedState:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserSeedState(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var columnImplementors = []string{"Column", "ColumnSeedStateInterface"}

func (ec *executionContext) _Column(ctx context.Context, sel ast.SelectionSet, obj *model.Column) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, columnImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Column")
		case "id":
			out.Values[i] = ec._Column_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Column_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Column_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "creator":
			out.Values[i] = ec._Column_creator(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Column_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subscribers":
			out.Values[i] = ec._Column_subscribers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feeds":
			out.Values[i] = ec._Column_feeds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "visibility":
			out.Values[i] = ec._Column_visibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subscriberCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Column_subscriberCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mobileNotification":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Column_mobileNotification(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "readed":
			out.Values[i] = ec._Column_readed(ctx, field, obj)
		case "webNotification":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Column_webNotification(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "showUnreadIndicatorOnIcon":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Column_showUnreadIndicatorOnIcon(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var columnSeedStateImplementors = []string{"ColumnSeedState", "ColumnSeedStateInterface"}

func (ec *executionContext) _ColumnSeedState(ctx context.Context, sel ast.SelectionSet, obj *model.ColumnSeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, columnSeedStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ColumnSeedState")
		case "id":
			out.Values[i] = ec._ColumnSeedState_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ColumnSeedState_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customizedCrawlerTestResponseImplementors = []string{"CustomizedCrawlerTestResponse"}

func (ec *executionContext) _CustomizedCrawlerTestResponse(ctx context.Context, sel ast.SelectionSet, obj *model.CustomizedCrawlerTestResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customizedCrawlerTestResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomizedCrawlerTestResponse")
		case "baseHtml":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_baseHtml(ctx, field, obj)
		case "title":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_title(ctx, field, obj)
		case "content":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_content(ctx, field, obj)
		case "externalId":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_externalId(ctx, field, obj)
		case "time":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_time(ctx, field, obj)
		case "images":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_images(ctx, field, obj)
		case "subsource":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_subsource(ctx, field, obj)
		case "originUrl":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_originUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedImplementors = []string{"Feed", "FeedSeedStateInterface"}

func (ec *executionContext) _Feed(ctx context.Context, sel ast.SelectionSet, obj *model.Feed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Feed")
		case "id":
			out.Values[i] = ec._Feed_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Feed_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Feed_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "creator":
			out.Values[i] = ec._Feed_creator(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Feed_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "posts":
			out.Values[i] = ec._Feed_posts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subSources":
			out.Values[i] = ec._Feed_subSources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "columns":
			out.Values[i] = ec._Feed_columns(ctx, field, obj)
		case "filterDataExpression":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_filterDataExpression(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "visibility":
			out.Values[i] = ec._Feed_visibility(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedSeedStateImplementors = []string{"FeedSeedState", "FeedSeedStateInterface"}

func (ec *executionContext) _FeedSeedState(ctx context.Context, sel ast.SelectionSet, obj *model.FeedSeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedSeedStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedSeedState")
		case "id":
			out.Values[i] = ec._FeedSeedState_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FeedSeedState_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "upsertFeed":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertFeed(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "upsertColumn":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertColumn(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteColumn":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteColumn(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createPost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subscribe":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_subscribe(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "upsertSubSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertSubSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addWeiboSubSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addWeiboSubSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addSubSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addSubSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSubSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSubSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "syncUp":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_syncUp(ctx, field)
			})
		case "setItemsReadStatus":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setItemsReadStatus(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setFeedFavorite":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setFeedFavorite(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setNotificationSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setNotificationSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var postImplementors = []string{"Post"}

func (ec *executionContext) _Post(ctx context.Context, sel ast.SelectionSet, obj *model.Post) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Post")
		case "id":
			out.Values[i] = ec._Post_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Post_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "title":
			out.Values[i] = ec._Post_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "content":
			out.Values[i] = ec._Post_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subSource":
			out.Values[i] = ec._Post_subSource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sharedFromPost":
			out.Values[i] = ec._Post_sharedFromPost(ctx, field, obj)
		case "readByUser":
			out.Values[i] = ec._Post_readByUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "publishedFeeds":
			out.Values[i] = ec._Post_publishedFeeds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cursor":
			out.Values[i] = ec._Post_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "imageUrls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_imageUrls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fileUrls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_fileUrls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "crawledAt":
			out.Values[i] = ec._Post_crawledAt(ctx, field, obj)
		case "originUrl":
			out.Values[i] = ec._Post_originUrl(ctx, field, obj)
		case "contentGeneratedAt":
			out.Values[i] = ec._Post_contentGeneratedAt(ctx, field, obj)
		case "inSharingChain":
			out.Values[i] = ec._Post_inSharingChain(ctx, field, obj)
		case "deduplicateId":
			out.Values[i] = ec._Post_deduplicateId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "semanticHashing":
			out.Values[i] = ec._Post_semanticHashing(ctx, field, obj)
		case "embedding":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_embedding(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "replyThread":
			out.Values[i] = ec._Post_replyThread(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isRead":
			out.Values[i] = ec._Post_isRead(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "delayed":
			out.Values[i] = ec._Post_delayed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var postInColumnOutputImplementors = []string{"PostInColumnOutput"}

func (ec *executionContext) _PostInColumnOutput(ctx context.Context, sel ast.SelectionSet, obj *model.PostInColumnOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postInColumnOutputImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PostInColumnOutput")
		case "post":
			out.Values[i] = ec._PostInColumnOutput_post(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._PostInColumnOutput_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var postInFeedOutputImplementors = []string{"PostInFeedOutput"}

func (ec *executionContext) _PostInFeedOutput(ctx context.Context, sel ast.SelectionSet, obj *model.PostInFeedOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postInFeedOutputImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PostInFeedOutput")
		case "post":
			out.Values[i] = ec._PostInFeedOutput_post(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._PostInFeedOutput_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "allVisibleColumns":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allVisibleColumns(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "favoriteFeeds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_favoriteFeeds(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "post":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_post(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "posts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_posts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userState":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userState(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "feeds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_feeds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "columns":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_columns(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "subSources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_subSources(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sources(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tryCustomizedCrawler":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tryCustomizedCrawler(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var seedStateImplementors = []string{"SeedState"}

func (ec *executionContext) _SeedState(ctx context.Context, sel ast.SelectionSet, obj *model.SeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, seedStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SeedState")
		case "userSeedState":
			out.Values[i] = ec._SeedState_userSeedState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "columnSeedState":
			out.Values[i] = ec._SeedState_columnSeedState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var signalImplementors = []string{"Signal"}

func (ec *executionContext) _Signal(ctx context.Context, sel ast.SelectionSet, obj *model.Signal) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signalImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Signal")
		case "signalType":
			out.Values[i] = ec._Signal_signalType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "signalPayload":
			out.Values[i] = ec._Signal_signalPayload(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sourceImplementors = []string{"Source"}

func (ec *executionContext) _Source(ctx context.Context, sel ast.SelectionSet, obj *model.Source) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Source")
		case "id":
			out.Values[i] = ec._Source_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Source_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Source_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "creator":
			out.Values[i] = ec._Source_creator(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Source_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "domain":
			out.Values[i] = ec._Source_domain(ctx, field, obj)
		case "subsources":
			out.Values[i] = ec._Source_subsources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subSourceImplementors = []string{"SubSource"}

func (ec *executionContext) _SubSource(ctx context.Context, sel ast.SelectionSet, obj *model.SubSource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subSourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SubSource")
		case "id":
			out.Values[i] = ec._SubSource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._SubSource_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SubSource_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "name":
			out.Values[i] = ec._SubSource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalIdentifier":
			out.Values[i] = ec._SubSource_externalIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "source":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SubSource_source(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "avatarUrl":
			out.Values[i] = ec._SubSource_avatarUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "originUrl":
			out.Values[i] = ec._SubSource_originUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isFromSharedPost":
			out.Values[i] = ec._SubSource_isFromSharedPost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "customizedCrawlerParams":
			out.Values[i] = ec._SubSource_customizedCrawlerParams(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "signal":
		return ec._Subscription_signal(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var userImplementors = []string{"User", "UserSeedStateInterface"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "avatarUrl":
			out.Values[i] = ec._User_avatarUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subscribedColumns":
			out.Values[i] = ec._User_subscribedColumns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "postsRead":
			out.Values[i] = ec._User_postsRead(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSeedStateImplementors = []string{"UserSeedState", "UserSeedStateInterface"}

func (ec *executionContext) _UserSeedState(ctx context.Context, sel ast.SelectionSet, obj *model.UserSeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSeedStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSeedState")
		case "id":
			out.Values[i] = ec._UserSeedState_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._UserSeedState_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "avatarUrl":
			out.Values[i] = ec._UserSeedState_avatarUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userStateImplementors = []string{"UserState"}

func (ec *executionContext) _UserState(ctx context.Context, sel ast.SelectionSet, obj *model.UserState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserState")
		case "user":
			out.Values[i] = ec._UserState_user(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddSubSourceInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐAddSubSourceInput(ctx context.Context, v interface{}) (model.AddSubSourceInput, error) {
	res, err := ec.unmarshalInputAddSubSourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAddWeiboSubSourceInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐAddWeiboSubSourceInput(ctx context.Context, v interface{}) (model.AddWeiboSubSourceInput, error) {
	res, err := ec.unmarshalInputAddWeiboSubSourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNColumn2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumn(ctx context.Context, sel ast.SelectionSet, v model.Column) graphql.Marshaler {
	return ec._Column(ctx, sel, &v)
}

func (ec *executionContext) marshalNColumn2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Column) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNColumn2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumn(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNColumn2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumn(ctx context.Context, sel ast.SelectionSet, v *model.Column) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Column(ctx, sel, v)
}

func (ec *executionContext) unmarshalNColumnRefreshInput2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnRefreshInputᚄ(ctx context.Context, v interface{}) ([]*model.ColumnRefreshInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.ColumnRefreshInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNColumnRefreshInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnRefreshInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNColumnRefreshInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnRefreshInput(ctx context.Context, v interface{}) (*model.ColumnRefreshInput, error) {
	res, err := ec.unmarshalInputColumnRefreshInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNColumnSeedState2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnSeedStateᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ColumnSeedState) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNColumnSeedState2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnSeedState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNColumnSeedState2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnSeedState(ctx context.Context, sel ast.SelectionSet, v *model.ColumnSeedState) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ColumnSeedState(ctx, sel, v)
}

func (ec *executionContext) unmarshalNColumnSeedStateInput2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnSeedStateInputᚄ(ctx context.Context, v interface{}) ([]*model.ColumnSeedStateInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.ColumnSeedStateInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNColumnSeedStateInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnSeedStateInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNColumnSeedStateInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnSeedStateInput(ctx context.Context, v interface{}) (*model.ColumnSeedStateInput, error) {
	res, err := ec.unmarshalInputColumnSeedStateInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCustomizedCrawlerParams2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerParams(ctx context.Context, v interface{}) (*model.CustomizedCrawlerParams, error) {
	res, err := ec.unmarshalInputCustomizedCrawlerParams(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCustomizedCrawlerTestResponse2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerTestResponse(ctx context.Context, sel ast.SelectionSet, v *model.CustomizedCrawlerTestResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CustomizedCrawlerTestResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteColumnInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐDeleteColumnInput(ctx context.Context, v interface{}) (model.DeleteColumnInput, error) {
	res, err := ec.unmarshalInputDeleteColumnInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeed2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeed(ctx context.Context, sel ast.SelectionSet, v model.Feed) graphql.Marshaler {
	return ec._Feed(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeed2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Feed) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeed2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeed2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeed(ctx context.Context, sel ast.SelectionSet, v *model.Feed) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Feed(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFeedRefreshDirection2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedRefreshDirection(ctx context.Context, v interface{}) (model.FeedRefreshDirection, error) {
	var res model.FeedRefreshDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeedRefreshDirection2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedRefreshDirection(ctx context.Context, sel ast.SelectionSet, v model.FeedRefreshDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFeedRefreshInput2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedRefreshInputᚄ(ctx context.Context, v interface{}) ([]*model.FeedRefreshInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FeedRefreshInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFeedRefreshInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedRefreshInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFeedRefreshInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedRefreshInput(ctx context.Context, v interface{}) (*model.FeedRefreshInput, error) {
	res, err := ec.unmarshalInputFeedRefreshInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNFloat2ᚕfloat64ᚄ(ctx context.Context, v interface{}) ([]float64, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFloat2float64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNFloat2ᚕfloat64ᚄ(ctx context.Context, sel ast.SelectionSet, v []float64) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNFloat2float64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int32(ctx context.Context, v interface{}) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	res := graphql.MarshalInt32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNItemType2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐItemType(ctx context.Context, v interface{}) (model.ItemType, error) {
	var res model.ItemType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemType2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐItemType(ctx context.Context, sel ast.SelectionSet, v model.ItemType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNNewPostInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐNewPostInput(ctx context.Context, v interface{}) (model.NewPostInput, error) {
	res, err := ec.unmarshalInputNewPostInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewSourceInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐNewSourceInput(ctx context.Context, v interface{}) (model.NewSourceInput, error) {
	res, err := ec.unmarshalInputNewSourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewUserInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐNewUserInput(ctx context.Context, v interface{}) (model.NewUserInput, error) {
	res, err := ec.unmarshalInputNewUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNotificationSettingInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐNotificationSettingInput(ctx context.Context, v interface{}) (model.NotificationSettingInput, error) {
	res, err := ec.unmarshalInputNotificationSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPost2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx context.Context, sel ast.SelectionSet, v model.Post) graphql.Marshaler {
	return ec._Post(ctx, sel, &v)
}

func (ec *executionContext) marshalNPost2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPostᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Post) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPost2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPost2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx context.Context, sel ast.SelectionSet, v *model.Post) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Post(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSearchPostsRefreshInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSearchPostsRefreshInput(ctx context.Context, v interface{}) (*model.SearchPostsRefreshInput, error) {
	res, err := ec.unmarshalInputSearchPostsRefreshInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSetFeedFavoriteInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSetFeedFavoriteInput(ctx context.Context, v interface{}) (model.SetFeedFavoriteInput, error) {
	res, err := ec.unmarshalInputSetFeedFavoriteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSetItemsReadStatusInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSetItemsReadStatusInput(ctx context.Context, v interface{}) (model.SetItemsReadStatusInput, error) {
	res, err := ec.unmarshalInputSetItemsReadStatusInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSignal2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSignal(ctx context.Context, sel ast.SelectionSet, v model.Signal) graphql.Marshaler {
	return ec._Signal(ctx, sel, &v)
}

func (ec *executionContext) marshalNSignal2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSignal(ctx context.Context, sel ast.SelectionSet, v *model.Signal) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Signal(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSignalType2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSignalType(ctx context.Context, v interface{}) (model.SignalType, error) {
	var res model.SignalType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSignalType2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSignalType(ctx context.Context, sel ast.SelectionSet, v model.SignalType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSource2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSource(ctx context.Context, sel ast.SelectionSet, v model.Source) graphql.Marshaler {
	return ec._Source(ctx, sel, &v)
}

func (ec *executionContext) marshalNSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSource(ctx context.Context, sel ast.SelectionSet, v *model.Source) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSubSource2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSource(ctx context.Context, sel ast.SelectionSet, v model.SubSource) graphql.Marshaler {
	return ec._SubSource(ctx, sel, &v)
}

func (ec *executionContext) marshalNSubSource2ᚕgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSourceᚄ(ctx context.Context, sel ast.SelectionSet, v []model.SubSource) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSubSource2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSubSource2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSourceᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.SubSource) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSubSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSubSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubSource(ctx context.Context, sel ast.SelectionSet, v *model.SubSource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SubSource(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSubscribeInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubscribeInput(ctx context.Context, v interface{}) (model.SubscribeInput, error) {
	res, err := ec.unmarshalInputSubscribeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpsertColumnInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUpsertColumnInput(ctx context.Context, v interface{}) (model.UpsertColumnInput, error) {
	res, err := ec.unmarshalInputUpsertColumnInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpsertFeedInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUpsertFeedInput(ctx context.Context, v interface{}) (model.UpsertFeedInput, error) {
	res, err := ec.unmarshalInputUpsertFeedInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpsertSubSourceInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUpsertSubSourceInput(ctx context.Context, v interface{}) (model.UpsertSubSourceInput, error) {
	res, err := ec.unmarshalInputUpsertSubSourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSeedState2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserSeedState(ctx context.Context, sel ast.SelectionSet, v *model.UserSeedState) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSeedState(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserSeedStateInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserSeedStateInput(ctx context.Context, v interface{}) (*model.UserSeedStateInput, error) {
	res, err := ec.unmarshalInputUserSeedStateInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserState2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserState(ctx context.Context, sel ast.SelectionSet, v model.UserState) graphql.Marshaler {
	return ec._UserState(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserState2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserState(ctx context.Context, sel ast.SelectionSet, v *model.UserState) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserState(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserStateInput2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserStateInput(ctx context.Context, v interface{}) (model.UserStateInput, error) {
	res, err := ec.unmarshalInputUserStateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNVisibility2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐVisibility(ctx context.Context, v interface{}) (model.Visibility, error) {
	var res model.Visibility
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVisibility2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐVisibility(ctx context.Context, sel ast.SelectionSet, v model.Visibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOColumn2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Column) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNColumn2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumn(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOColumnsGetPostsInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐColumnsGetPostsInput(ctx context.Context, v interface{}) (*model.ColumnsGetPostsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputColumnsGetPostsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCustomizedCrawlerPanopticConfigForm2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerPanopticConfigForm(ctx context.Context, v interface{}) (*model.CustomizedCrawlerPanopticConfigForm, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCustomizedCrawlerPanopticConfigForm(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCustomizedCrawlerParams2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerParams(ctx context.Context, v interface{}) (*model.CustomizedCrawlerParams, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCustomizedCrawlerParams(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCustomizedCrawlerTestResponse2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerTestResponseᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CustomizedCrawlerTestResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCustomizedCrawlerTestResponse2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐCustomizedCrawlerTestResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODeleteSubSourceInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐDeleteSubSourceInput(ctx context.Context, v interface{}) (*model.DeleteSubSourceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDeleteSubSourceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeed2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Feed) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeed2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFeedsGetPostsInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐFeedsGetPostsInput(ctx context.Context, v interface{}) (*model.FeedsGetPostsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedsGetPostsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOPost2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPostᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Post) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPost2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPost2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPost(ctx context.Context, sel ast.SelectionSet, v *model.Post) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Post(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPostInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐPostInput(ctx context.Context, v interface{}) (*model.PostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORefreshFilterInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐRefreshFilterInput(ctx context.Context, v interface{}) (*model.RefreshFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRefreshFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchPostsInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSearchPostsInput(ctx context.Context, v interface{}) (*model.SearchPostsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchPostsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSeedState2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSeedState(ctx context.Context, sel ast.SelectionSet, v *model.SeedState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SeedState(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSeedStateInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSeedStateInput(ctx context.Context, v interface{}) (*model.SeedStateInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSeedStateInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSource2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSourceᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Source) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSource2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSourcesInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSourcesInput(ctx context.Context, v interface{}) (*model.SourcesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSourcesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOSubsourcesInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐSubsourcesInput(ctx context.Context, v interface{}) (*model.SubsourcesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSubsourcesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚕᚖtimeᚐTime(ctx context.Context, v interface{}) ([]*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2ᚕᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v []*time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOTime2ᚖtimeᚐTime(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2ᚕᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserIdInput2ᚖgithubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐUserIDInput(ctx context.Context, v interface{}) (*model.UserIDInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserIdInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOVisibility2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐVisibility(ctx context.Context, v interface{}) (model.Visibility, error) {
	var res model.Visibility
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVisibility2githubᚗcomᚋrnrᚑcapitalᚋnewsfeedᚑbackendᚋmodelᚐVisibility(ctx context.Context, sel ast.SelectionSet, v model.Visibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
