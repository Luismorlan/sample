// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/rnr-capital/newsfeed-backend/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Column() ColumnResolver
	Feed() FeedResolver
	Mutation() MutationResolver
	Post() PostResolver
	Query() QueryResolver
	Source() SourceResolver
	SubSource() SubSourceResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Column struct {
		CreatedAt                 func(childComplexity int) int
		Creator                   func(childComplexity int) int
		Feeds                     func(childComplexity int) int
		Id                        func(childComplexity int) int
		MobileNotification        func(childComplexity int) int
		Name                      func(childComplexity int) int
		Readed                    func(childComplexity int) int
		ShowUnreadIndicatorOnIcon func(childComplexity int) int
		SubscriberCount           func(childComplexity int) int
		Subscribers               func(childComplexity int) int
		UpdatedAt                 func(childComplexity int) int
		Visibility                func(childComplexity int) int
		WebNotification           func(childComplexity int) int
	}

	ColumnSeedState struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	CustomizedCrawlerTestResponse struct {
		BaseHTML   func(childComplexity int) int
		Content    func(childComplexity int) int
		ExternalID func(childComplexity int) int
		Images     func(childComplexity int) int
		OriginURL  func(childComplexity int) int
		Subsource  func(childComplexity int) int
		Time       func(childComplexity int) int
		Title      func(childComplexity int) int
	}

	Feed struct {
		Columns              func(childComplexity int) int
		CreatedAt            func(childComplexity int) int
		Creator              func(childComplexity int) int
		FilterDataExpression func(childComplexity int) int
		Id                   func(childComplexity int) int
		Name                 func(childComplexity int) int
		Posts                func(childComplexity int) int
		SubSources           func(childComplexity int) int
		UpdatedAt            func(childComplexity int) int
		Visibility           func(childComplexity int) int
	}

	FeedSeedState struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Mutation struct {
		AddSubSource           func(childComplexity int, input model.AddSubSourceInput) int
		AddWeiboSubSource      func(childComplexity int, input model.AddWeiboSubSourceInput) int
		CreatePost             func(childComplexity int, input model.NewPostInput) int
		CreateSource           func(childComplexity int, input model.NewSourceInput) int
		CreateUser             func(childComplexity int, input model.NewUserInput) int
		DeleteColumn           func(childComplexity int, input model.DeleteColumnInput) int
		DeleteSubSource        func(childComplexity int, input *model.DeleteSubSourceInput) int
		SetFeedFavorite        func(childComplexity int, input model.SetFeedFavoriteInput) int
		SetItemsReadStatus     func(childComplexity int, input model.SetItemsReadStatusInput) int
		SetNotificationSetting func(childComplexity int, input model.NotificationSettingInput) int
		Subscribe              func(childComplexity int, input model.SubscribeInput) int
		SyncUp                 func(childComplexity int, input *model.SeedStateInput) int
		UpsertColumn           func(childComplexity int, input model.UpsertColumnInput) int
		UpsertFeed             func(childComplexity int, input model.UpsertFeedInput) int
		UpsertSubSource        func(childComplexity int, input model.UpsertSubSourceInput) int
	}

	Post struct {
		Content            func(childComplexity int) int
		ContentGeneratedAt func(childComplexity int) int
		CrawledAt          func(childComplexity int) int
		CreatedAt          func(childComplexity int) int
		Cursor             func(childComplexity int) int
		DeduplicateId      func(childComplexity int) int
		Delayed            func(childComplexity int) int
		DeletedAt          func(childComplexity int) int
		Embedding          func(childComplexity int) int
		FileUrls           func(childComplexity int) int
		Id                 func(childComplexity int) int
		ImageUrls          func(childComplexity int) int
		InSharingChain     func(childComplexity int) int
		IsRead             func(childComplexity int) int
		OriginUrl          func(childComplexity int) int
		PublishedFeeds     func(childComplexity int) int
		ReadByUser         func(childComplexity int) int
		ReplyThread        func(childComplexity int) int
		SemanticHashing    func(childComplexity int) int
		SharedFromPost     func(childComplexity int) int
		SubSource          func(childComplexity int) int
		Tags               func(childComplexity int) int
		Title              func(childComplexity int) int
	}

	PostInColumnOutput struct {
		Cursor func(childComplexity int) int
		Post   func(childComplexity int) int
	}

	PostInFeedOutput struct {
		Cursor func(childComplexity int) int
		Post   func(childComplexity int) int
	}

	Query struct {
		AllVisibleColumns    func(childComplexity int) int
		Columns              func(childComplexity int, input *model.ColumnsGetPostsInput) int
		FavoriteFeeds        func(childComplexity int, input *model.UserIDInput) int
		Feeds                func(childComplexity int, input *model.FeedsGetPostsInput) int
		Post                 func(childComplexity int, input *model.PostInput) int
		Posts                func(childComplexity int, input *model.SearchPostsInput) int
		Sources              func(childComplexity int, input *model.SourcesInput) int
		SubSources           func(childComplexity int, input *model.SubsourcesInput) int
		TryCustomizedCrawler func(childComplexity int, input *model.CustomizedCrawlerParams) int
		UserState            func(childComplexity int, input model.UserStateInput) int
		Users                func(childComplexity int) int
	}

	SeedState struct {
		ColumnSeedState func(childComplexity int) int
		UserSeedState   func(childComplexity int) int
	}

	Signal struct {
		SignalPayload func(childComplexity int) int
		SignalType    func(childComplexity int) int
	}

	Source struct {
		CreatedAt  func(childComplexity int) int
		Creator    func(childComplexity int) int
		DeletedAt  func(childComplexity int) int
		Domain     func(childComplexity int) int
		Id         func(childComplexity int) int
		Name       func(childComplexity int) int
		SubSources func(childComplexity int) int
	}

	SubSource struct {
		AvatarUrl               func(childComplexity int) int
		CreatedAt               func(childComplexity int) int
		CustomizedCrawlerParams func(childComplexity int) int
		DeletedAt               func(childComplexity int) int
		ExternalIdentifier      func(childComplexity int) int
		Id                      func(childComplexity int) int
		IsFromSharedPost        func(childComplexity int) int
		Name                    func(childComplexity int) int
		OriginUrl               func(childComplexity int) int
		Source                  func(childComplexity int) int
	}

	Subscription struct {
		Signal func(childComplexity int, userID string) int
	}

	User struct {
		AvatarUrl         func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Id                func(childComplexity int) int
		Name              func(childComplexity int) int
		PostsRead         func(childComplexity int) int
		SubscribedColumns func(childComplexity int) int
	}

	UserSeedState struct {
		AvatarURL func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
	}

	UserState struct {
		User func(childComplexity int) int
	}
}

type ColumnResolver interface {
	SubscriberCount(ctx context.Context, obj *model.Column) (*int, error)
	MobileNotification(ctx context.Context, obj *model.Column) (bool, error)

	WebNotification(ctx context.Context, obj *model.Column) (bool, error)
	ShowUnreadIndicatorOnIcon(ctx context.Context, obj *model.Column) (bool, error)
}
type FeedResolver interface {
	FilterDataExpression(ctx context.Context, obj *model.Feed) (string, error)
}
type MutationResolver interface {
	CreateUser(ctx context.Context, input model.NewUserInput) (*model.User, error)
	UpsertFeed(ctx context.Context, input model.UpsertFeedInput) (*model.Feed, error)
	UpsertColumn(ctx context.Context, input model.UpsertColumnInput) (*model.Column, error)
	DeleteColumn(ctx context.Context, input model.DeleteColumnInput) (*model.Column, error)
	CreatePost(ctx context.Context, input model.NewPostInput) (*model.Post, error)
	Subscribe(ctx context.Context, input model.SubscribeInput) (*model.User, error)
	CreateSource(ctx context.Context, input model.NewSourceInput) (*model.Source, error)
	UpsertSubSource(ctx context.Context, input model.UpsertSubSourceInput) (*model.SubSource, error)
	AddWeiboSubSource(ctx context.Context, input model.AddWeiboSubSourceInput) (*model.SubSource, error)
	AddSubSource(ctx context.Context, input model.AddSubSourceInput) (*model.SubSource, error)
	DeleteSubSource(ctx context.Context, input *model.DeleteSubSourceInput) (*model.SubSource, error)
	SyncUp(ctx context.Context, input *model.SeedStateInput) (*model.SeedState, error)
	SetItemsReadStatus(ctx context.Context, input model.SetItemsReadStatusInput) (bool, error)
	SetFeedFavorite(ctx context.Context, input model.SetFeedFavoriteInput) (bool, error)
	SetNotificationSetting(ctx context.Context, input model.NotificationSettingInput) (bool, error)
}
type PostResolver interface {
	DeletedAt(ctx context.Context, obj *model.Post) (*time.Time, error)

	ImageUrls(ctx context.Context, obj *model.Post) ([]string, error)
	FileUrls(ctx context.Context, obj *model.Post) ([]string, error)

	Embedding(ctx context.Context, obj *model.Post) ([]float64, error)

	Tags(ctx context.Context, obj *model.Post) ([]string, error)
}
type QueryResolver interface {
	AllVisibleColumns(ctx context.Context) ([]*model.Column, error)
	FavoriteFeeds(ctx context.Context, input *model.UserIDInput) ([]*model.Feed, error)
	Post(ctx context.Context, input *model.PostInput) (*model.Post, error)
	Posts(ctx context.Context, input *model.SearchPostsInput) ([]*model.Post, error)
	Users(ctx context.Context) ([]*model.User, error)
	UserState(ctx context.Context, input model.UserStateInput) (*model.UserState, error)
	Feeds(ctx context.Context, input *model.FeedsGetPostsInput) ([]*model.Feed, error)
	Columns(ctx context.Context, input *model.ColumnsGetPostsInput) ([]*model.Column, error)
	SubSources(ctx context.Context, input *model.SubsourcesInput) ([]*model.SubSource, error)
	Sources(ctx context.Context, input *model.SourcesInput) ([]*model.Source, error)
	TryCustomizedCrawler(ctx context.Context, input *model.CustomizedCrawlerParams) ([]*model.CustomizedCrawlerTestResponse, error)
}
type SourceResolver interface {
	DeletedAt(ctx context.Context, obj *model.Source) (*time.Time, error)
}
type SubSourceResolver interface {
	DeletedAt(ctx context.Context, obj *model.SubSource) (*time.Time, error)

	Source(ctx context.Context, obj *model.SubSource) (*model.Source, error)
}
type SubscriptionResolver interface {
	Signal(ctx context.Context, userID string) (<-chan *model.Signal, error)
}
type UserResolver interface {
	DeletedAt(ctx context.Context, obj *model.User) (*time.Time, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Column.createdAt":
		if e.complexity.Column.CreatedAt == nil {
			break
		}

		return e.complexity.Column.CreatedAt(childComplexity), true

	case "Column.creator":
		if e.complexity.Column.Creator == nil {
			break
		}

		return e.complexity.Column.Creator(childComplexity), true

	case "Column.feeds":
		if e.complexity.Column.Feeds == nil {
			break
		}

		return e.complexity.Column.Feeds(childComplexity), true

	case "Column.id":
		if e.complexity.Column.Id == nil {
			break
		}

		return e.complexity.Column.Id(childComplexity), true

	case "Column.mobileNotification":
		if e.complexity.Column.MobileNotification == nil {
			break
		}

		return e.complexity.Column.MobileNotification(childComplexity), true

	case "Column.name":
		if e.complexity.Column.Name == nil {
			break
		}

		return e.complexity.Column.Name(childComplexity), true

	case "Column.readed":
		if e.complexity.Column.Readed == nil {
			break
		}

		return e.complexity.Column.Readed(childComplexity), true

	case "Column.showUnreadIndicatorOnIcon":
		if e.complexity.Column.ShowUnreadIndicatorOnIcon == nil {
			break
		}

		return e.complexity.Column.ShowUnreadIndicatorOnIcon(childComplexity), true

	case "Column.subscriberCount":
		if e.complexity.Column.SubscriberCount == nil {
			break
		}

		return e.complexity.Column.SubscriberCount(childComplexity), true

	case "Column.subscribers":
		if e.complexity.Column.Subscribers == nil {
			break
		}

		return e.complexity.Column.Subscribers(childComplexity), true

	case "Column.updatedAt":
		if e.complexity.Column.UpdatedAt == nil {
			break
		}

		return e.complexity.Column.UpdatedAt(childComplexity), true

	case "Column.visibility":
		if e.complexity.Column.Visibility == nil {
			break
		}

		return e.complexity.Column.Visibility(childComplexity), true

	case "Column.webNotification":
		if e.complexity.Column.WebNotification == nil {
			break
		}

		return e.complexity.Column.WebNotification(childComplexity), true

	case "ColumnSeedState.id":
		if e.complexity.ColumnSeedState.ID == nil {
			break
		}

		return e.complexity.ColumnSeedState.ID(childComplexity), true

	case "ColumnSeedState.name":
		if e.complexity.ColumnSeedState.Name == nil {
			break
		}

		return e.complexity.ColumnSeedState.Name(childComplexity), true

	case "CustomizedCrawlerTestResponse.baseHtml":
		if e.complexity.CustomizedCrawlerTestResponse.BaseHTML == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.BaseHTML(childComplexity), true

	case "CustomizedCrawlerTestResponse.content":
		if e.complexity.CustomizedCrawlerTestResponse.Content == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Content(childComplexity), true

	case "CustomizedCrawlerTestResponse.externalId":
		if e.complexity.CustomizedCrawlerTestResponse.ExternalID == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.ExternalID(childComplexity), true

	case "CustomizedCrawlerTestResponse.images":
		if e.complexity.CustomizedCrawlerTestResponse.Images == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Images(childComplexity), true

	case "CustomizedCrawlerTestResponse.originUrl":
		if e.complexity.CustomizedCrawlerTestResponse.OriginURL == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.OriginURL(childComplexity), true

	case "CustomizedCrawlerTestResponse.subsource":
		if e.complexity.CustomizedCrawlerTestResponse.Subsource == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Subsource(childComplexity), true

	case "CustomizedCrawlerTestResponse.time":
		if e.complexity.CustomizedCrawlerTestResponse.Time == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Time(childComplexity), true

	case "CustomizedCrawlerTestResponse.title":
		if e.complexity.CustomizedCrawlerTestResponse.Title == nil {
			break
		}

		return e.complexity.CustomizedCrawlerTestResponse.Title(childComplexity), true

	case "Feed.columns":
		if e.complexity.Feed.Columns == nil {
			break
		}

		return e.complexity.Feed.Columns(childComplexity), true

	case "Feed.createdAt":
		if e.complexity.Feed.CreatedAt == nil {
			break
		}

		return e.complexity.Feed.CreatedAt(childComplexity), true

	case "Feed.creator":
		if e.complexity.Feed.Creator == nil {
			break
		}

		return e.complexity.Feed.Creator(childComplexity), true

	case "Feed.filterDataExpression":
		if e.complexity.Feed.FilterDataExpression == nil {
			break
		}

		return e.complexity.Feed.FilterDataExpression(childComplexity), true

	case "Feed.id":
		if e.complexity.Feed.Id == nil {
			break
		}

		return e.complexity.Feed.Id(childComplexity), true

	case "Feed.name":
		if e.complexity.Feed.Name == nil {
			break
		}

		return e.complexity.Feed.Name(childComplexity), true

	case "Feed.posts":
		if e.complexity.Feed.Posts == nil {
			break
		}

		return e.complexity.Feed.Posts(childComplexity), true

	case "Feed.subSources":
		if e.complexity.Feed.SubSources == nil {
			break
		}

		return e.complexity.Feed.SubSources(childComplexity), true

	case "Feed.updatedAt":
		if e.complexity.Feed.UpdatedAt == nil {
			break
		}

		return e.complexity.Feed.UpdatedAt(childComplexity), true

	case "Feed.visibility":
		if e.complexity.Feed.Visibility == nil {
			break
		}

		return e.complexity.Feed.Visibility(childComplexity), true

	case "FeedSeedState.id":
		if e.complexity.FeedSeedState.ID == nil {
			break
		}

		return e.complexity.FeedSeedState.ID(childComplexity), true

	case "FeedSeedState.name":
		if e.complexity.FeedSeedState.Name == nil {
			break
		}

		return e.complexity.FeedSeedState.Name(childComplexity), true

	case "Mutation.addSubSource":
		if e.complexity.Mutation.AddSubSource == nil {
			break
		}

		args, err := ec.field_Mutation_addSubSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddSubSource(childComplexity, args["input"].(model.AddSubSourceInput)), true

	case "Mutation.addWeiboSubSource":
		if e.complexity.Mutation.AddWeiboSubSource == nil {
			break
		}

		args, err := ec.field_Mutation_addWeiboSubSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddWeiboSubSource(childComplexity, args["input"].(model.AddWeiboSubSourceInput)), true

	case "Mutation.createPost":
		if e.complexity.Mutation.CreatePost == nil {
			break
		}

		args, err := ec.field_Mutation_createPost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePost(childComplexity, args["input"].(model.NewPostInput)), true

	case "Mutation.createSource":
		if e.complexity.Mutation.CreateSource == nil {
			break
		}

		args, err := ec.field_Mutation_createSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSource(childComplexity, args["input"].(model.NewSourceInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.NewUserInput)), true

	case "Mutation.deleteColumn":
		if e.complexity.Mutation.DeleteColumn == nil {
			break
		}

		args, err := ec.field_Mutation_deleteColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteColumn(childComplexity, args["input"].(model.DeleteColumnInput)), true

	case "Mutation.deleteSubSource":
		if e.complexity.Mutation.DeleteSubSource == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSubSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSubSource(childComplexity, args["input"].(*model.DeleteSubSourceInput)), true

	case "Mutation.setFeedFavorite":
		if e.complexity.Mutation.SetFeedFavorite == nil {
			break
		}

		args, err := ec.field_Mutation_setFeedFavorite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetFeedFavorite(childComplexity, args["input"].(model.SetFeedFavoriteInput)), true

	case "Mutation.setItemsReadStatus":
		if e.complexity.Mutation.SetItemsReadStatus == nil {
			break
		}

		args, err := ec.field_Mutation_setItemsReadStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetItemsReadStatus(childComplexity, args["input"].(model.SetItemsReadStatusInput)), true

	case "Mutation.setNotificationSetting":
		if e.complexity.Mutation.SetNotificationSetting == nil {
			break
		}

		args, err := ec.field_Mutation_setNotificationSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetNotificationSetting(childComplexity, args["input"].(model.NotificationSettingInput)), true

	case "Mutation.subscribe":
		if e.complexity.Mutation.Subscribe == nil {
			break
		}

		args, err := ec.field_Mutation_subscribe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Subscribe(childComplexity, args["input"].(model.SubscribeInput)), true

	case "Mutation.syncUp":
		if e.complexity.Mutation.SyncUp == nil {
			break
		}

		args, err := ec.field_Mutation_syncUp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncUp(childComplexity, args["input"].(*model.SeedStateInput)), true

	case "Mutation.upsertColumn":
		if e.complexity.Mutation.UpsertColumn == nil {
			break
		}

		args, err := ec.field_Mutation_upsertColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertColumn(childComplexity, args["input"].(model.UpsertColumnInput)), true

	case "Mutation.upsertFeed":
		if e.complexity.Mutation.UpsertFeed == nil {
			break
		}

		args, err := ec.field_Mutation_upsertFeed_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertFeed(childComplexity, args["input"].(model.UpsertFeedInput)), true

	case "Mutation.upsertSubSource":
		if e.complexity.Mutation.UpsertSubSource == nil {
			break
		}

		args, err := ec.field_Mutation_upsertSubSource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertSubSource(childComplexity, args["input"].(model.UpsertSubSourceInput)), true

	case "Post.content":
		if e.complexity.Post.Content == nil {
			break
		}

		return e.complexity.Post.Content(childComplexity), true

	case "Post.contentGeneratedAt":
		if e.complexity.Post.ContentGeneratedAt == nil {
			break
		}

		return e.complexity.Post.ContentGeneratedAt(childComplexity), true

	case "Post.crawledAt":
		if e.complexity.Post.CrawledAt == nil {
			break
		}

		return e.complexity.Post.CrawledAt(childComplexity), true

	case "Post.createdAt":
		if e.complexity.Post.CreatedAt == nil {
			break
		}

		return e.complexity.Post.CreatedAt(childComplexity), true

	case "Post.cursor":
		if e.complexity.Post.Cursor == nil {
			break
		}

		return e.complexity.Post.Cursor(childComplexity), true

	case "Post.deduplicateId":
		if e.complexity.Post.DeduplicateId == nil {
			break
		}

		return e.complexity.Post.DeduplicateId(childComplexity), true

	case "Post.delayed":
		if e.complexity.Post.Delayed == nil {
			break
		}

		return e.complexity.Post.Delayed(childComplexity), true

	case "Post.deletedAt":
		if e.complexity.Post.DeletedAt == nil {
			break
		}

		return e.complexity.Post.DeletedAt(childComplexity), true

	case "Post.embedding":
		if e.complexity.Post.Embedding == nil {
			break
		}

		return e.complexity.Post.Embedding(childComplexity), true

	case "Post.fileUrls":
		if e.complexity.Post.FileUrls == nil {
			break
		}

		return e.complexity.Post.FileUrls(childComplexity), true

	case "Post.id":
		if e.complexity.Post.Id == nil {
			break
		}

		return e.complexity.Post.Id(childComplexity), true

	case "Post.imageUrls":
		if e.complexity.Post.ImageUrls == nil {
			break
		}

		return e.complexity.Post.ImageUrls(childComplexity), true

	case "Post.inSharingChain":
		if e.complexity.Post.InSharingChain == nil {
			break
		}

		return e.complexity.Post.InSharingChain(childComplexity), true

	case "Post.isRead":
		if e.complexity.Post.IsRead == nil {
			break
		}

		return e.complexity.Post.IsRead(childComplexity), true

	case "Post.originUrl":
		if e.complexity.Post.OriginUrl == nil {
			break
		}

		return e.complexity.Post.OriginUrl(childComplexity), true

	case "Post.publishedFeeds":
		if e.complexity.Post.PublishedFeeds == nil {
			break
		}

		return e.complexity.Post.PublishedFeeds(childComplexity), true

	case "Post.readByUser":
		if e.complexity.Post.ReadByUser == nil {
			break
		}

		return e.complexity.Post.ReadByUser(childComplexity), true

	case "Post.replyThread":
		if e.complexity.Post.ReplyThread == nil {
			break
		}

		return e.complexity.Post.ReplyThread(childComplexity), true

	case "Post.semanticHashing":
		if e.complexity.Post.SemanticHashing == nil {
			break
		}

		return e.complexity.Post.SemanticHashing(childComplexity), true

	case "Post.sharedFromPost":
		if e.complexity.Post.SharedFromPost == nil {
			break
		}

		return e.complexity.Post.SharedFromPost(childComplexity), true

	case "Post.subSource":
		if e.complexity.Post.SubSource == nil {
			break
		}

		return e.complexity.Post.SubSource(childComplexity), true

	case "Post.tags":
		if e.complexity.Post.Tags == nil {
			break
		}

		return e.complexity.Post.Tags(childComplexity), true

	case "Post.title":
		if e.complexity.Post.Title == nil {
			break
		}

		return e.complexity.Post.Title(childComplexity), true

	case "PostInColumnOutput.cursor":
		if e.complexity.PostInColumnOutput.Cursor == nil {
			break
		}

		return e.complexity.PostInColumnOutput.Cursor(childComplexity), true

	case "PostInColumnOutput.post":
		if e.complexity.PostInColumnOutput.Post == nil {
			break
		}

		return e.complexity.PostInColumnOutput.Post(childComplexity), true

	case "PostInFeedOutput.cursor":
		if e.complexity.PostInFeedOutput.Cursor == nil {
			break
		}

		return e.complexity.PostInFeedOutput.Cursor(childComplexity), true

	case "PostInFeedOutput.post":
		if e.complexity.PostInFeedOutput.Post == nil {
			break
		}

		return e.complexity.PostInFeedOutput.Post(childComplexity), true

	case "Query.allVisibleColumns":
		if e.complexity.Query.AllVisibleColumns == nil {
			break
		}

		return e.complexity.Query.AllVisibleColumns(childComplexity), true

	case "Query.columns":
		if e.complexity.Query.Columns == nil {
			break
		}

		args, err := ec.field_Query_columns_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Columns(childComplexity, args["input"].(*model.ColumnsGetPostsInput)), true

	case "Query.favoriteFeeds":
		if e.complexity.Query.FavoriteFeeds == nil {
			break
		}

		args, err := ec.field_Query_favoriteFeeds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FavoriteFeeds(childComplexity, args["input"].(*model.UserIDInput)), true

	case "Query.feeds":
		if e.complexity.Query.Feeds == nil {
			break
		}

		args, err := ec.field_Query_feeds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Feeds(childComplexity, args["input"].(*model.FeedsGetPostsInput)), true

	case "Query.post":
		if e.complexity.Query.Post == nil {
			break
		}

		args, err := ec.field_Query_post_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Post(childComplexity, args["input"].(*model.PostInput)), true

	case "Query.posts":
		if e.complexity.Query.Posts == nil {
			break
		}

		args, err := ec.field_Query_posts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Posts(childComplexity, args["input"].(*model.SearchPostsInput)), true

	case "Query.sources":
		if e.complexity.Query.Sources == nil {
			break
		}

		args, err := ec.field_Query_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sources(childComplexity, args["input"].(*model.SourcesInput)), true

	case "Query.subSources":
		if e.complexity.Query.SubSources == nil {
			break
		}

		args, err := ec.field_Query_subSources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SubSources(childComplexity, args["input"].(*model.SubsourcesInput)), true

	case "Query.tryCustomizedCrawler":
		if e.complexity.Query.TryCustomizedCrawler == nil {
			break
		}

		args, err := ec.field_Query_tryCustomizedCrawler_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TryCustomizedCrawler(childComplexity, args["input"].(*model.CustomizedCrawlerParams)), true

	case "Query.userState":
		if e.complexity.Query.UserState == nil {
			break
		}

		args, err := ec.field_Query_userState_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserState(childComplexity, args["input"].(model.UserStateInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "SeedState.columnSeedState":
		if e.complexity.SeedState.ColumnSeedState == nil {
			break
		}

		return e.complexity.SeedState.ColumnSeedState(childComplexity), true

	case "SeedState.userSeedState":
		if e.complexity.SeedState.UserSeedState == nil {
			break
		}

		return e.complexity.SeedState.UserSeedState(childComplexity), true

	case "Signal.signalPayload":
		if e.complexity.Signal.SignalPayload == nil {
			break
		}

		return e.complexity.Signal.SignalPayload(childComplexity), true

	case "Signal.signalType":
		if e.complexity.Signal.SignalType == nil {
			break
		}

		return e.complexity.Signal.SignalType(childComplexity), true

	case "Source.createdAt":
		if e.complexity.Source.CreatedAt == nil {
			break
		}

		return e.complexity.Source.CreatedAt(childComplexity), true

	case "Source.creator":
		if e.complexity.Source.Creator == nil {
			break
		}

		return e.complexity.Source.Creator(childComplexity), true

	case "Source.deletedAt":
		if e.complexity.Source.DeletedAt == nil {
			break
		}

		return e.complexity.Source.DeletedAt(childComplexity), true

	case "Source.domain":
		if e.complexity.Source.Domain == nil {
			break
		}

		return e.complexity.Source.Domain(childComplexity), true

	case "Source.id":
		if e.complexity.Source.Id == nil {
			break
		}

		return e.complexity.Source.Id(childComplexity), true

	case "Source.name":
		if e.complexity.Source.Name == nil {
			break
		}

		return e.complexity.Source.Name(childComplexity), true

	case "Source.subsources":
		if e.complexity.Source.SubSources == nil {
			break
		}

		return e.complexity.Source.SubSources(childComplexity), true

	case "SubSource.avatarUrl":
		if e.complexity.SubSource.AvatarUrl == nil {
			break
		}

		return e.complexity.SubSource.AvatarUrl(childComplexity), true

	case "SubSource.createdAt":
		if e.complexity.SubSource.CreatedAt == nil {
			break
		}

		return e.complexity.SubSource.CreatedAt(childComplexity), true

	case "SubSource.customizedCrawlerParams":
		if e.complexity.SubSource.CustomizedCrawlerParams == nil {
			break
		}

		return e.complexity.SubSource.CustomizedCrawlerParams(childComplexity), true

	case "SubSource.deletedAt":
		if e.complexity.SubSource.DeletedAt == nil {
			break
		}

		return e.complexity.SubSource.DeletedAt(childComplexity), true

	case "SubSource.externalIdentifier":
		if e.complexity.SubSource.ExternalIdentifier == nil {
			break
		}

		return e.complexity.SubSource.ExternalIdentifier(childComplexity), true

	case "SubSource.id":
		if e.complexity.SubSource.Id == nil {
			break
		}

		return e.complexity.SubSource.Id(childComplexity), true

	case "SubSource.isFromSharedPost":
		if e.complexity.SubSource.IsFromSharedPost == nil {
			break
		}

		return e.complexity.SubSource.IsFromSharedPost(childComplexity), true

	case "SubSource.name":
		if e.complexity.SubSource.Name == nil {
			break
		}

		return e.complexity.SubSource.Name(childComplexity), true

	case "SubSource.originUrl":
		if e.complexity.SubSource.OriginUrl == nil {
			break
		}

		return e.complexity.SubSource.OriginUrl(childComplexity), true

	case "SubSource.source":
		if e.complexity.SubSource.Source == nil {
			break
		}

		return e.complexity.SubSource.Source(childComplexity), true

	case "Subscription.signal":
		if e.complexity.Subscription.Signal == nil {
			break
		}

		args, err := ec.field_Subscription_signal_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Signal(childComplexity, args["userId"].(string)), true

	case "User.avatarUrl":
		if e.complexity.User.AvatarUrl == nil {
			break
		}

		return e.complexity.User.AvatarUrl(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.deletedAt":
		if e.complexity.User.DeletedAt == nil {
			break
		}

		return e.complexity.User.DeletedAt(childComplexity), true

	case "User.id":
		if e.complexity.User.Id == nil {
			break
		}

		return e.complexity.User.Id(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.postsRead":
		if e.complexity.User.PostsRead == nil {
			break
		}

		return e.complexity.User.PostsRead(childComplexity), true

	case "User.subscribedColumns":
		if e.complexity.User.SubscribedColumns == nil {
			break
		}

		return e.complexity.User.SubscribedColumns(childComplexity), true

	case "UserSeedState.avatarUrl":
		if e.complexity.UserSeedState.AvatarURL == nil {
			break
		}

		return e.complexity.UserSeedState.AvatarURL(childComplexity), true

	case "UserSeedState.id":
		if e.complexity.UserSeedState.ID == nil {
			break
		}

		return e.complexity.UserSeedState.ID(childComplexity), true

	case "UserSeedState.name":
		if e.complexity.UserSeedState.Name == nil {
			break
		}

		return e.complexity.UserSeedState.Name(childComplexity), true

	case "UserState.user":
		if e.complexity.UserState.User == nil {
			break
		}

		return e.complexity.UserState.User(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddSubSourceInput,
		ec.unmarshalInputAddWeiboSubSourceInput,
		ec.unmarshalInputColumnRefreshInput,
		ec.unmarshalInputColumnSeedStateInput,
		ec.unmarshalInputColumnsGetPostsInput,
		ec.unmarshalInputCustomizedCrawlerPanopticConfigForm,
		ec.unmarshalInputCustomizedCrawlerParams,
		ec.unmarshalInputDeleteColumnInput,
		ec.unmarshalInputDeleteSubSourceInput,
		ec.unmarshalInputFeedRefreshInput,
		ec.unmarshalInputFeedSeedStateInput,
		ec.unmarshalInputFeedsGetPostsInput,
		ec.unmarshalInputNewPostInput,
		ec.unmarshalInputNewSourceInput,
		ec.unmarshalInputNewUserInput,
		ec.unmarshalInputNotificationSettingInput,
		ec.unmarshalInputPostInput,
		ec.unmarshalInputRefreshFilterInput,
		ec.unmarshalInputSearchPostsInput,
		ec.unmarshalInputSearchPostsRefreshInput,
		ec.unmarshalInputSeedStateInput,
		ec.unmarshalInputSetFeedFavoriteInput,
		ec.unmarshalInputSetItemsReadStatusInput,
		ec.unmarshalInputSourcesInput,
		ec.unmarshalInputSubscribeInput,
		ec.unmarshalInputSubsourcesInput,
		ec.unmarshalInputUpsertColumnInput,
		ec.unmarshalInputUpsertFeedInput,
		ec.unmarshalInputUpsertSubSourceInput,
		ec.unmarshalInputUserIdInput,
		ec.unmarshalInputUserSeedStateInput,
		ec.unmarshalInputUserStateInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../column.graphqls", Input: `type Column implements ColumnSeedStateInterface
  @goModel(model: "model.Column") {
  id: String!
  createdAt: Time!
  updatedAt: Time!
  creator: User
  name: String!
  subscribers: [User!]!
  feeds: [Feed!]!
  visibility: Visibility!
  # How many users are subscribing to this Column, used in sharedColumn.
  subscriberCount: Int
  mobileNotification: Boolean!
  readed: [String!]
  webNotification: Boolean!
  showUnreadIndicatorOnIcon: Boolean!
}

type ColumnSeedState implements ColumnSeedStateInterface {
  id: String!
  name: String!
}

input ColumnSeedStateInput {
  id: String!
  name: String!
}

interface ColumnSeedStateInterface {
  id: String!
  name: String!
}

type PostInColumnOutput {
  post: Post!
  cursor: Int!
}
`, BuiltIn: false},
	{Name: "../customizedCrawlerTest.graphqls", Input: `type CustomizedCrawlerTestResponse {
  baseHtml: String
  title: String
  content: String
  externalId: String
  time: String
  images: [String!]
  subsource: String
  originUrl: String
}
`, BuiltIn: false},
	{Name: "../directives.graphqls", Input: `# GQL Directives
# This part is fairly necessary and is described in the gql documentation
# https://gqlgen.com/config/
directive @goModel(model: String, models: [String!]) on OBJECT
    | INPUT_OBJECT
    | SCALAR
    | ENUM
    | INTERFACE
    | UNION

directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION
    | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../feed.graphqls", Input: `type Feed implements FeedSeedStateInterface @goModel(model: "model.Feed") {
  id: String!
  createdAt: Time!
  updatedAt: Time!
  creator: User
  name: String!
  posts: [Post!]!
  subSources: [SubSource!]!
  columns: [Column!]
  filterDataExpression: String!
  visibility: Visibility
}

type FeedSeedState implements FeedSeedStateInterface {
  id: String!
  name: String!
}

input FeedSeedStateInput {
  id: String!
  name: String!
}

interface FeedSeedStateInterface {
  id: String!
  name: String!
}

type PostInFeedOutput {
  post: Post!
  cursor: Int!
}
`, BuiltIn: false},
	{Name: "../post.graphqls", Input: `type Post @goModel(model: "model.Post") {
  id: String!
  createdAt: Time!
  deletedAt: Time
  title: String!
  content: String!
  subSource: SubSource!
  sharedFromPost: Post
  readByUser: [User!]!
  publishedFeeds: [Feed!]!
  cursor: Int!
  # urls to resources
  imageUrls: [String!]!
  fileUrls: [String!]!

  # Time when crawler finished crawling this post
  crawledAt: Time

  # url from where this post is crawled
  originUrl: String

  # actual time content is generated by 3rd party website
  contentGeneratedAt: Time

  # is the post shared by another post, if true, this post will not be published if it is not published
  inSharingChain: Boolean

  # deduplicate id is generated by crawler, purely depends on logic in crawler
  deduplicateId: String!

  semanticHashing: String
  embedding: [Float!]!

  # the parent post of this thread in chronological order, together with this
  # post they form a thread.
  replyThread: [Post!]!

  # tags indicating post content
  tags: [String!]!

  # indicating if the post has been read
  isRead: Boolean!

  # indicating if the post is delayed
  delayed: Boolean!
}
`, BuiltIn: false},
	{Name: "../schema.graphqls", Input: `# GraphQL schema

enum FeedRefreshDirection {
  NEW
  OLD
}

enum Visibility {
  GLOBAL
  PRIVATE
}

enum ItemType {
  POST
  DUPLICATION
}

input SourcesInput {
  subSourceFromSharedPost: Boolean!
}

input SubsourcesInput {
  isFromSharedPost: Boolean!
  isCustomized: Boolean
}

input PostInput {
  id: String!
}

input NewUserInput {
  id: String!
  name: String!
}

# TODO(BONING): deprecate visibility
input UpsertFeedInput {
  columnId: String
  userId: String!
  feedId: String
  name: String!
  filterDataExpression: String!
  subSourceIds: [String!]!
  addToColumn: Boolean!
}

# TODO(BONING): we shouldn't need to edit feeds in this input?
input UpsertColumnInput {
  columnId: String
  userId: String!
  name: String!
  visibility: Visibility!
  feedIds: [String!]
}

# TODO: for testing purpose, real post is created by crawler and publisher
input NewPostInput {
  title: String!
  content: String!
  subSourceId: String!
  feedsIdPublishTo: [String!]
  sharedFromPostId: String
}

input SubscribeInput {
  userId: String!
  columnId: String!
}

input NotificationSettingInput {
  userId: String!
  columnId: String!
  mobile: Boolean!
  web: Boolean!
  unreadIndicatorOnIcon: Boolean!
}

input NewSourceInput {
  userId: String!
  name: String!
  domain: String!
  customizedCrawlerPanopticConfigForm: CustomizedCrawlerPanopticConfigForm
}

# This schema has all information needed to construct a PanopticConfig in panoptic_config.proto
# data_collector_id is predefined to be COLLECTOR_USER_CUSTOMIZED_SOURCE
input CustomizedCrawlerPanopticConfigForm {
  name: String # name of the config if not specified, use source name
  # for TaskSchedule:
  startImmediately: Boolean # default to true
  scheduleEveryMilliseconds: Int # default to 5 minutes
  # for CustomizedCrawlerParams
  customizedCrawlerParams: CustomizedCrawlerParams!
}

# This schema has all information needed to construct a CustomizedCrawlerParams in panoptic.proto
input CustomizedCrawlerParams {
  crawlUrl: String! # url to crawl, e.g. https://www.cls.cn/telegraph
  baseSelector: String! # base selector should return a list of DOM elements where each one corresponds to a single post
  titleRelativeSelector: String # relative selector to the base selector
  contentRelativeSelector: String
  externalIdRelativeSelector: String
  timeRelativeSelector: String #if not specified, use the cralwed time as content generated time
  imageRelativeSelector: String
  subsourceRelativeSelector: String #how to deal with subsource spec
  originUrlRelativeSelector: String #by default is the url
  originUrlIsRelativePath: Boolean #if the originUrlRelativeSelector generates relative path to crawlUrl
}

# isFromSharedPost = true means the subsource is not for cralwing
# it is from a shared post
# example: when subsource is an owner of a post in a retweet post
input UpsertSubSourceInput {
  # disable subsource id, use name + source id to identify
  # subSourceId: String
  name: String!
  externalIdentifier: String!
  sourceId: String!
  avatarUrl: String!
  originUrl: String!
  isFromSharedPost: Boolean!

  # use this to customize crawler behavior, the source should have
  # collector_id = COLLECTOR_USER_CUSTOMIZED_SUBSOURCE in config
  customizedCrawlerParams: CustomizedCrawlerParams
}

input DeleteSubSourceInput {
  subsourceId: String!
}

# Add weibo user to the database for panoptic to crawl
input AddWeiboSubSourceInput {
  name: String!
}

input AddSubSourceInput {
  # SourceId to which this subSource belongs to.
  sourceId: String!
  # subSourceUserName is the actual username for a given Source.
  subSourceUserName: String!
}

input FeedRefreshInput {
  feedId: String!
  limit: Int!
  cursor: Int!
  direction: FeedRefreshDirection!
  feedUpdatedTime: Time
  query: String
  filter: RefreshFilterInput
}

input RefreshFilterInput {
  unread: Boolean
}

input ColumnRefreshInput {
  columnId: String!
  limit: Int!
  direction: FeedRefreshDirection!
  cursor: Int!
  otherEndCursor: Int

  feedIds: [String!]!
  feedUpdatedTimes: [Time]
  columnUpdatedTime: Time
  query: String
  filter: RefreshFilterInput
}

input SearchPostsRefreshInput {
  limit: Int!
  direction: FeedRefreshDirection!
  cursor: Int!
  otherEndCursor: Int
  query: String
  filter: RefreshFilterInput
}

input SearchPostsInput {
  userId: String!
  searchPostsRefreshInput: SearchPostsRefreshInput!
}

input FeedsGetPostsInput {
  userId: String!
  feedRefreshInputs: [FeedRefreshInput!]!
}

input ColumnsGetPostsInput {
  userId: String!
  columnsRefreshInputs: [ColumnRefreshInput!]!
}

input UserIdInput {
  userId: String!
}

input DeleteColumnInput {
  userId: String!
  columnId: String!
}

input SetItemsReadStatusInput {
  userId: String!
  itemNodeIds: [String!]!
  read: Boolean!
  type: ItemType!
}

input SetFeedFavoriteInput {
  userId: String!
  feedId: String!
  isFavorite: Boolean!
}

type Query {
  allVisibleColumns: [Column!]
  favoriteFeeds(input: UserIdInput): [Feed!]
  post(input: PostInput): Post!
  posts(input: SearchPostsInput): [Post!]!
  users: [User!]

  # postsReadStatus(input: GetPostsReadStatusInput!): [Boolean!]!
  # State is the main API to "bootstrap" application, where it fetches required
  # states for the given input. After receiving the StateOutput, client will
  # then make subsequent calls to request all data.
  userState(input: UserStateInput!): UserState!

  # Feeds is the main API for newsfeed
  # WARNING: if you do not pass feedUpdatedTime, your curosr/direction will be ignored
  # WARNING: please pass the cursor based on returned posts cursor, otherwise the republish will skip some posts

  # It is used to return posts for a feed
  # It can be called with a list of following queries, each query represent a feed
  # Caller can specify only 1 or more feeds

  # FeedID          string					Feed id to fetch posts
  # Limit           int						Max amount of posts shall the API return, at most 30
  # Cursor          int						The cursor of the pivot post
  # Direction       FeedRefreshDirection	NEW or OLD description below
  # FeedUpdatedTime *time.Time				Time stamp used to represent feed version description below

  # Returns: Feeds
  # 	caller can get each feed's FeedUpdatedTime and its posts, and each post has a cursor

  # How to use cursor and direction?
  # 	Direction = NEW:    load feed new posts with cursor larger than cursor A (default -1), from newest one, no more than Limit
  # 	Direction = OLD: load feed old posts with cursor smaller than cursor B (default -1), from newest one, no more than Limit

  # 	If not specified, use NEW as direction, -1 as cursor to give newest Posts

  # 	How is cursor defined:
  # 		it is an auto-increament index Posts

  # What if feed is changed, and front end doesn't know?
  # Feed updates are not pushed to frontend, backend pass a turn-around field FeedUpdatedTime
  # 	to frontend, and API call will carry this timestamp. Once feed is updated, API will know the
  # 	input timestamp is not same as the updated "FeedUpdatedTime", thus, will not respect the cursor

  # If frontend disconnected for a while, how do front end know it gets all posts up until latest?
  # In this case, front end can still query {Feeds} with its stored NEWest cursor
  # 	{Feeds} will return the most recent N post up to N=Limit
  # 	Front end can check if the N == Limit, if so, it indicate there is very likely to be more posts
  # 	need to be fetched. And frontend can send another {Feeds} request. It can also choose not
  # 	to fetch so many posts.

  # What if the data expression filter or subsource are changed
  # Chaging feed is on {upsertFeed}
  # For {feeds} we will handle on-the-fly posts re-publish, in these conditions:
  # 1. query OLD but can't satisfy the limit
  feeds(input: FeedsGetPostsInput): [Feed!]!
  columns(input: ColumnsGetPostsInput): [Column!]!

  subSources(input: SubsourcesInput): [SubSource!]!
  sources(input: SourcesInput): [Source!]

  tryCustomizedCrawler(
    input: CustomizedCrawlerParams
  ): [CustomizedCrawlerTestResponse!]
}

type Mutation {
  createUser(input: NewUserInput!): User!
  upsertFeed(input: UpsertFeedInput!): Feed!
  upsertColumn(input: UpsertColumnInput!): Column!
  deleteColumn(input: DeleteColumnInput!): Column!

  # TODO: for testing purpose, real post is created by crawler and publisher
  createPost(input: NewPostInput!): Post!
  # TODO: what should be a better output
  subscribe(input: SubscribeInput!): User!

  createSource(input: NewSourceInput!): Source!
  upsertSubSource(input: UpsertSubSourceInput!): SubSource!

  # Deprecated!
  # TODO(chenweilunster): Remove this function and all its existence.
  addWeiboSubSource(input: AddWeiboSubSourceInput!): SubSource!

  # For now, addSubSource is used when frontend wants to add some more
  # subSources for a given source (e.g. Weibo, Twitter). It should validate the
  # input, store the normalized version, and return the error code if any.
  # This mutation isn't intended to be used as a generic AddSubSource method for
  # now, but it can be extended to be a generic one.
  addSubSource(input: AddSubSourceInput!): SubSource!
  deleteSubSource(input: DeleteSubSourceInput): SubSource!

  syncUp(input: SeedStateInput): SeedState

  setItemsReadStatus(input: SetItemsReadStatusInput!): Boolean!
  setFeedFavorite(input: SetFeedFavoriteInput!): Boolean!

  setNotificationSetting(input: NotificationSettingInput!): Boolean!
}

type Subscription {
  # Subscribe to signals sending from server side. Client side should handle
  # signals properly. The first time this is called will always return
  # SEEDSTATE signal.
  signal(userId: String!): Signal!
}

scalar Time
`, BuiltIn: false},
	{Name: "../seedState.graphqls", Input: `type SeedState @goModel(model: "model.SeedState") {
  userSeedState: UserSeedState!
  columnSeedState: [ColumnSeedState!]!
}

input SeedStateInput {
  userSeedState: UserSeedStateInput!
  columnSeedState: [ColumnSeedStateInput!]!
}
`, BuiltIn: false},
	{Name: "../signal.graphqls", Input: `# Each SignalType instruct the client side application to do some certain thing.
enum SignalType {
  # Instruct client side to pull seed state. This is the first signal send to
  # client side application.
  SEED_STATE
  SET_ITEMS_READ_STATUS
}

type Signal @goModel(model: "model.Signal") {
  signalType: SignalType!

  # sigalPayload is a general payload, and each type of signal needs to parse its own payload
  # the parser should be added to signal_payload.go
  signalPayload: String

  # Some signal also need params, adding all custom params below this line.
}
`, BuiltIn: false},
	{Name: "../source.graphqls", Input: `type Source @goModel(model: "model.Source") {
  id: String!
  createdAt: Time!
  deletedAt: Time
  creator: User
  name: String!
  domain: String
  subsources: [SubSource!]!
}
`, BuiltIn: false},
	{Name: "../subsource.graphqls", Input: `type SubSource @goModel(model: "model.SubSource") {
  id: String!
  createdAt: Time!
  deletedAt: Time
  name: String!
  externalIdentifier: String!
  source: Source!
  avatarUrl: String!
  originUrl: String!
  isFromSharedPost: Boolean!
  customizedCrawlerParams: String
}
`, BuiltIn: false},
	{Name: "../user.graphqls", Input: `type User implements UserSeedStateInterface @goModel(model: "model.User") {
  id: String!
  createdAt: Time!
  deletedAt: Time
  name: String!
  avatarUrl: String!
  subscribedColumns: [Column!]!
  postsRead: [Post!]
}

type UserSeedState implements UserSeedStateInterface {
  id: String!
  name: String!
  avatarUrl: String!
}

input UserSeedStateInput {
  id: String!
  name: String!
  avatarUrl: String!
}

interface UserSeedStateInterface {
  id: String!
  name: String!
  avatarUrl: String!
}
`, BuiltIn: false},
	{Name: "../userState.graphqls", Input: `input UserStateInput {
  userId: String!
}

type UserState @goModel(model: "model.UserState") {
  user: User
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addSubSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AddSubSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddSubSourceInput2githubcomrnrcapitalnewsfeedbackendmodelAddSubSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addWeiboSubSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AddWeiboSubSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAddWeiboSubSourceInput2githubcomrnrcapitalnewsfeedbackendmodelAddWeiboSubSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewPostInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNewPostInput2githubcomrnrcapitalnewsfeedbackendmodelNewPostInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNewSourceInput2githubcomrnrcapitalnewsfeedbackendmodelNewSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NewUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNewUserInput2githubcomrnrcapitalnewsfeedbackendmodelNewUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteColumn_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DeleteColumnInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteColumnInput2githubcomrnrcapitalnewsfeedbackendmodelDeleteColumnInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSubSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.DeleteSubSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteSubSourceInput2githubcomrnrcapitalnewsfeedbackendmodelDeleteSubSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setFeedFavorite_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SetFeedFavoriteInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSetFeedFavoriteInput2githubcomrnrcapitalnewsfeedbackendmodelSetFeedFavoriteInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setItemsReadStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SetItemsReadStatusInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSetItemsReadStatusInput2githubcomrnrcapitalnewsfeedbackendmodelSetItemsReadStatusInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setNotificationSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NotificationSettingInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNotificationSettingInput2githubcomrnrcapitalnewsfeedbackendmodelNotificationSettingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_subscribe_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SubscribeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSubscribeInput2githubcomrnrcapitalnewsfeedbackendmodelSubscribeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_syncUp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SeedStateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOSeedStateInput2githubcomrnrcapitalnewsfeedbackendmodelSeedStateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertColumn_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpsertColumnInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertColumnInput2githubcomrnrcapitalnewsfeedbackendmodelUpsertColumnInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertFeed_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpsertFeedInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertFeedInput2githubcomrnrcapitalnewsfeedbackendmodelUpsertFeedInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_upsertSubSource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpsertSubSourceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpsertSubSourceInput2githubcomrnrcapitalnewsfeedbackendmodelUpsertSubSourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_columns_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.ColumnsGetPostsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOColumnsGetPostsInput2githubcomrnrcapitalnewsfeedbackendmodelColumnsGetPostsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_favoriteFeeds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.UserIDInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUserIdInput2githubcomrnrcapitalnewsfeedbackendmodelUserIDInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_feeds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.FeedsGetPostsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOFeedsGetPostsInput2githubcomrnrcapitalnewsfeedbackendmodelFeedsGetPostsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_post_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.PostInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOPostInput2githubcomrnrcapitalnewsfeedbackendmodelPostInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_posts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SearchPostsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOSearchPostsInput2githubcomrnrcapitalnewsfeedbackendmodelSearchPostsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SourcesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOSourcesInput2githubcomrnrcapitalnewsfeedbackendmodelSourcesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_subSources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SubsourcesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOSubsourcesInput2githubcomrnrcapitalnewsfeedbackendmodelSubsourcesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tryCustomizedCrawler_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.CustomizedCrawlerParams
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCustomizedCrawlerParams2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerParams(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userState_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UserStateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUserStateInput2githubcomrnrcapitalnewsfeedbackendmodelUserStateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_signal_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Column_id(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_creator(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_name(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_subscribers(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_subscribers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscribers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_subscribers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_feeds(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_feeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Feeds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_feeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_visibility(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Visibility)
	fc.Result = res
	return ec.marshalNVisibility2githubcomrnrcapitalnewsfeedbackendmodelVisibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Visibility does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_subscriberCount(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_subscriberCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Column().SubscriberCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_subscriberCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_mobileNotification(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_mobileNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Column().MobileNotification(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_mobileNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_readed(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_readed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Readed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_readed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_webNotification(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_webNotification(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Column().WebNotification(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_webNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Column_showUnreadIndicatorOnIcon(ctx context.Context, field graphql.CollectedField, obj *model.Column) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Column().ShowUnreadIndicatorOnIcon(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Column_showUnreadIndicatorOnIcon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Column",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ColumnSeedState_id(ctx context.Context, field graphql.CollectedField, obj *model.ColumnSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ColumnSeedState_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ColumnSeedState_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ColumnSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ColumnSeedState_name(ctx context.Context, field graphql.CollectedField, obj *model.ColumnSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ColumnSeedState_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ColumnSeedState_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ColumnSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_baseHtml(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_baseHtml(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseHTML, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_baseHtml(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_title(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_content(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_externalId(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_externalId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_externalId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_time(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_images(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Images, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_images(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_subsource(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_subsource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subsource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_subsource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomizedCrawlerTestResponse_originUrl(ctx context.Context, field graphql.CollectedField, obj *model.CustomizedCrawlerTestResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomizedCrawlerTestResponse_originUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OriginURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomizedCrawlerTestResponse_originUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomizedCrawlerTestResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_id(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_creator(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_name(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_posts(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Posts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_subSources(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_subSources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubSources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_subSources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_columns(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_columns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Columns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Column)
	fc.Result = res
	return ec.marshalOColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_columns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_filterDataExpression(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_filterDataExpression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().FilterDataExpression(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_filterDataExpression(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_visibility(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Visibility)
	fc.Result = res
	return ec.marshalOVisibility2githubcomrnrcapitalnewsfeedbackendmodelVisibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Visibility does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedSeedState_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedSeedState_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedSeedState_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedSeedState_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedSeedState_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedSeedState_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["input"].(model.NewUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertFeed(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertFeed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertFeed(rctx, fc.Args["input"].(model.UpsertFeedInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertFeed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertFeed_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertColumn(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertColumn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertColumn(rctx, fc.Args["input"].(model.UpsertColumnInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Column)
	fc.Result = res
	return ec.marshalNColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertColumn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertColumn_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteColumn(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteColumn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteColumn(rctx, fc.Args["input"].(model.DeleteColumnInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Column)
	fc.Result = res
	return ec.marshalNColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteColumn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteColumn_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePost(rctx, fc.Args["input"].(model.NewPostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_subscribe(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_subscribe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Subscribe(rctx, fc.Args["input"].(model.SubscribeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_subscribe(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_subscribe_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSource(rctx, fc.Args["input"].(model.NewSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Source)
	fc.Result = res
	return ec.marshalNSource2githubcomrnrcapitalnewsfeedbackendmodelSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Source_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Source_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Source_deletedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Source_creator(ctx, field)
			case "name":
				return ec.fieldContext_Source_name(ctx, field)
			case "domain":
				return ec.fieldContext_Source_domain(ctx, field)
			case "subsources":
				return ec.fieldContext_Source_subsources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_upsertSubSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_upsertSubSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpsertSubSource(rctx, fc.Args["input"].(model.UpsertSubSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_upsertSubSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_upsertSubSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addWeiboSubSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addWeiboSubSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddWeiboSubSource(rctx, fc.Args["input"].(model.AddWeiboSubSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addWeiboSubSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addWeiboSubSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addSubSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addSubSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddSubSource(rctx, fc.Args["input"].(model.AddSubSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addSubSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addSubSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSubSource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSubSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSubSource(rctx, fc.Args["input"].(*model.DeleteSubSourceInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSubSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSubSource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_syncUp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_syncUp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SyncUp(rctx, fc.Args["input"].(*model.SeedStateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SeedState)
	fc.Result = res
	return ec.marshalOSeedState2githubcomrnrcapitalnewsfeedbackendmodelSeedState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_syncUp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userSeedState":
				return ec.fieldContext_SeedState_userSeedState(ctx, field)
			case "columnSeedState":
				return ec.fieldContext_SeedState_columnSeedState(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SeedState", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_syncUp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setItemsReadStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setItemsReadStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetItemsReadStatus(rctx, fc.Args["input"].(model.SetItemsReadStatusInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setItemsReadStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setItemsReadStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setFeedFavorite(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setFeedFavorite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetFeedFavorite(rctx, fc.Args["input"].(model.SetFeedFavoriteInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setFeedFavorite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setFeedFavorite_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setNotificationSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setNotificationSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetNotificationSetting(rctx, fc.Args["input"].(model.NotificationSettingInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setNotificationSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setNotificationSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Post_id(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_title(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_content(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_subSource(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_subSource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubSource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_subSource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_sharedFromPost(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_sharedFromPost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SharedFromPost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalOPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_sharedFromPost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_readByUser(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_readByUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReadByUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_readByUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_publishedFeeds(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_publishedFeeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublishedFeeds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_publishedFeeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_cursor(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_imageUrls(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_imageUrls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().ImageUrls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_imageUrls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_fileUrls(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_fileUrls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().FileUrls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_fileUrls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_crawledAt(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_crawledAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CrawledAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_crawledAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_originUrl(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_originUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OriginUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_originUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_contentGeneratedAt(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_contentGeneratedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentGeneratedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_contentGeneratedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_inSharingChain(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_inSharingChain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InSharingChain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_inSharingChain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_deduplicateId(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_deduplicateId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeduplicateId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_deduplicateId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_semanticHashing(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_semanticHashing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SemanticHashing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_semanticHashing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_embedding(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_embedding(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().Embedding(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_embedding(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_replyThread(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_replyThread(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReplyThread, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_replyThread(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_tags(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Post().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_isRead(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_isRead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRead, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_isRead(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_delayed(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_delayed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Delayed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_delayed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostInColumnOutput_post(ctx context.Context, field graphql.CollectedField, obj *model.PostInColumnOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostInColumnOutput_post(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Post, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostInColumnOutput_post(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostInColumnOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostInColumnOutput_cursor(ctx context.Context, field graphql.CollectedField, obj *model.PostInColumnOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostInColumnOutput_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostInColumnOutput_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostInColumnOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostInFeedOutput_post(ctx context.Context, field graphql.CollectedField, obj *model.PostInFeedOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostInFeedOutput_post(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Post, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostInFeedOutput_post(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostInFeedOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostInFeedOutput_cursor(ctx context.Context, field graphql.CollectedField, obj *model.PostInFeedOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PostInFeedOutput_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PostInFeedOutput_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostInFeedOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_allVisibleColumns(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_allVisibleColumns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllVisibleColumns(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Column)
	fc.Result = res
	return ec.marshalOColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_allVisibleColumns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_favoriteFeeds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_favoriteFeeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FavoriteFeeds(rctx, fc.Args["input"].(*model.UserIDInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalOFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_favoriteFeeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_favoriteFeeds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_post(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_post(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Post(rctx, fc.Args["input"].(*model.PostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_post(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_post_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_posts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Posts(rctx, fc.Args["input"].(*model.SearchPostsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_posts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_userState(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserState(rctx, fc.Args["input"].(model.UserStateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserState)
	fc.Result = res
	return ec.marshalNUserState2githubcomrnrcapitalnewsfeedbackendmodelUserState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserState_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserState", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userState_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_feeds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_feeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Feeds(rctx, fc.Args["input"].(*model.FeedsGetPostsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_feeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Feed_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Feed_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Feed_creator(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "posts":
				return ec.fieldContext_Feed_posts(ctx, field)
			case "subSources":
				return ec.fieldContext_Feed_subSources(ctx, field)
			case "columns":
				return ec.fieldContext_Feed_columns(ctx, field)
			case "filterDataExpression":
				return ec.fieldContext_Feed_filterDataExpression(ctx, field)
			case "visibility":
				return ec.fieldContext_Feed_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_feeds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_columns(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_columns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Columns(rctx, fc.Args["input"].(*model.ColumnsGetPostsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Column)
	fc.Result = res
	return ec.marshalNColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_columns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_columns_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_subSources(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_subSources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SubSources(rctx, fc.Args["input"].(*model.SubsourcesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_subSources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_subSources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sources(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_sources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Sources(rctx, fc.Args["input"].(*model.SourcesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Source)
	fc.Result = res
	return ec.marshalOSource2githubcomrnrcapitalnewsfeedbackendmodelSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_sources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Source_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Source_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Source_deletedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Source_creator(ctx, field)
			case "name":
				return ec.fieldContext_Source_name(ctx, field)
			case "domain":
				return ec.fieldContext_Source_domain(ctx, field)
			case "subsources":
				return ec.fieldContext_Source_subsources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tryCustomizedCrawler(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tryCustomizedCrawler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TryCustomizedCrawler(rctx, fc.Args["input"].(*model.CustomizedCrawlerParams))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CustomizedCrawlerTestResponse)
	fc.Result = res
	return ec.marshalOCustomizedCrawlerTestResponse2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerTestResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tryCustomizedCrawler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "baseHtml":
				return ec.fieldContext_CustomizedCrawlerTestResponse_baseHtml(ctx, field)
			case "title":
				return ec.fieldContext_CustomizedCrawlerTestResponse_title(ctx, field)
			case "content":
				return ec.fieldContext_CustomizedCrawlerTestResponse_content(ctx, field)
			case "externalId":
				return ec.fieldContext_CustomizedCrawlerTestResponse_externalId(ctx, field)
			case "time":
				return ec.fieldContext_CustomizedCrawlerTestResponse_time(ctx, field)
			case "images":
				return ec.fieldContext_CustomizedCrawlerTestResponse_images(ctx, field)
			case "subsource":
				return ec.fieldContext_CustomizedCrawlerTestResponse_subsource(ctx, field)
			case "originUrl":
				return ec.fieldContext_CustomizedCrawlerTestResponse_originUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomizedCrawlerTestResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tryCustomizedCrawler_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeedState_userSeedState(ctx context.Context, field graphql.CollectedField, obj *model.SeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeedState_userSeedState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSeedState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserSeedState)
	fc.Result = res
	return ec.marshalNUserSeedState2githubcomrnrcapitalnewsfeedbackendmodelUserSeedState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeedState_userSeedState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserSeedState_id(ctx, field)
			case "name":
				return ec.fieldContext_UserSeedState_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_UserSeedState_avatarUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSeedState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeedState_columnSeedState(ctx context.Context, field graphql.CollectedField, obj *model.SeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeedState_columnSeedState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColumnSeedState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ColumnSeedState)
	fc.Result = res
	return ec.marshalNColumnSeedState2githubcomrnrcapitalnewsfeedbackendmodelColumnSeedState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeedState_columnSeedState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ColumnSeedState_id(ctx, field)
			case "name":
				return ec.fieldContext_ColumnSeedState_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ColumnSeedState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signal_signalType(ctx context.Context, field graphql.CollectedField, obj *model.Signal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signal_signalType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignalType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.SignalType)
	fc.Result = res
	return ec.marshalNSignalType2githubcomrnrcapitalnewsfeedbackendmodelSignalType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signal_signalType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SignalType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signal_signalPayload(ctx context.Context, field graphql.CollectedField, obj *model.Signal) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signal_signalPayload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignalPayload, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signal_signalPayload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signal",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_id(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Source().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_creator(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_creator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_name(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_domain(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_domain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_domain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_subsources(ctx context.Context, field graphql.CollectedField, obj *model.Source) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_subsources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubSources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.SubSource)
	fc.Result = res
	return ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_subsources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SubSource_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_SubSource_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_SubSource_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_SubSource_name(ctx, field)
			case "externalIdentifier":
				return ec.fieldContext_SubSource_externalIdentifier(ctx, field)
			case "source":
				return ec.fieldContext_SubSource_source(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_SubSource_avatarUrl(ctx, field)
			case "originUrl":
				return ec.fieldContext_SubSource_originUrl(ctx, field)
			case "isFromSharedPost":
				return ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
			case "customizedCrawlerParams":
				return ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_id(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SubSource().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_name(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_externalIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_externalIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_externalIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_source(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SubSource().Source(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Source)
	fc.Result = res
	return ec.marshalNSource2githubcomrnrcapitalnewsfeedbackendmodelSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Source_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Source_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Source_deletedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Source_creator(ctx, field)
			case "name":
				return ec.fieldContext_Source_name(ctx, field)
			case "domain":
				return ec.fieldContext_Source_domain(ctx, field)
			case "subsources":
				return ec.fieldContext_Source_subsources(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_avatarUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_originUrl(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_originUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OriginUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_originUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_isFromSharedPost(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_isFromSharedPost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsFromSharedPost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_isFromSharedPost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubSource_customizedCrawlerParams(ctx context.Context, field graphql.CollectedField, obj *model.SubSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubSource_customizedCrawlerParams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CustomizedCrawlerParams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubSource_customizedCrawlerParams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_signal(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_signal(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Signal(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Signal):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNSignal2githubcomrnrcapitalnewsfeedbackendmodelSignal(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_signal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "signalType":
				return ec.fieldContext_Signal_signalType(ctx, field)
			case "signalPayload":
				return ec.fieldContext_Signal_signalPayload(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Signal", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_signal_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().DeletedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_avatarUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_subscribedColumns(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_subscribedColumns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscribedColumns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Column)
	fc.Result = res
	return ec.marshalNColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_subscribedColumns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Column_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Column_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Column_updatedAt(ctx, field)
			case "creator":
				return ec.fieldContext_Column_creator(ctx, field)
			case "name":
				return ec.fieldContext_Column_name(ctx, field)
			case "subscribers":
				return ec.fieldContext_Column_subscribers(ctx, field)
			case "feeds":
				return ec.fieldContext_Column_feeds(ctx, field)
			case "visibility":
				return ec.fieldContext_Column_visibility(ctx, field)
			case "subscriberCount":
				return ec.fieldContext_Column_subscriberCount(ctx, field)
			case "mobileNotification":
				return ec.fieldContext_Column_mobileNotification(ctx, field)
			case "readed":
				return ec.fieldContext_Column_readed(ctx, field)
			case "webNotification":
				return ec.fieldContext_Column_webNotification(ctx, field)
			case "showUnreadIndicatorOnIcon":
				return ec.fieldContext_Column_showUnreadIndicatorOnIcon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Column", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_postsRead(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_postsRead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostsRead, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalOPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_postsRead(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Post_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Post_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Post_deletedAt(ctx, field)
			case "title":
				return ec.fieldContext_Post_title(ctx, field)
			case "content":
				return ec.fieldContext_Post_content(ctx, field)
			case "subSource":
				return ec.fieldContext_Post_subSource(ctx, field)
			case "sharedFromPost":
				return ec.fieldContext_Post_sharedFromPost(ctx, field)
			case "readByUser":
				return ec.fieldContext_Post_readByUser(ctx, field)
			case "publishedFeeds":
				return ec.fieldContext_Post_publishedFeeds(ctx, field)
			case "cursor":
				return ec.fieldContext_Post_cursor(ctx, field)
			case "imageUrls":
				return ec.fieldContext_Post_imageUrls(ctx, field)
			case "fileUrls":
				return ec.fieldContext_Post_fileUrls(ctx, field)
			case "crawledAt":
				return ec.fieldContext_Post_crawledAt(ctx, field)
			case "originUrl":
				return ec.fieldContext_Post_originUrl(ctx, field)
			case "contentGeneratedAt":
				return ec.fieldContext_Post_contentGeneratedAt(ctx, field)
			case "inSharingChain":
				return ec.fieldContext_Post_inSharingChain(ctx, field)
			case "deduplicateId":
				return ec.fieldContext_Post_deduplicateId(ctx, field)
			case "semanticHashing":
				return ec.fieldContext_Post_semanticHashing(ctx, field)
			case "embedding":
				return ec.fieldContext_Post_embedding(ctx, field)
			case "replyThread":
				return ec.fieldContext_Post_replyThread(ctx, field)
			case "tags":
				return ec.fieldContext_Post_tags(ctx, field)
			case "isRead":
				return ec.fieldContext_Post_isRead(ctx, field)
			case "delayed":
				return ec.fieldContext_Post_delayed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSeedState_id(ctx context.Context, field graphql.CollectedField, obj *model.UserSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSeedState_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSeedState_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSeedState_name(ctx context.Context, field graphql.CollectedField, obj *model.UserSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSeedState_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSeedState_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSeedState_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *model.UserSeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSeedState_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSeedState_avatarUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserState_user(ctx context.Context, field graphql.CollectedField, obj *model.UserState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserState_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserState_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_User_avatarUrl(ctx, field)
			case "subscribedColumns":
				return ec.fieldContext_User_subscribedColumns(ctx, field)
			case "postsRead":
				return ec.fieldContext_User_postsRead(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddSubSourceInput(ctx context.Context, obj interface{}) (model.AddSubSourceInput, error) {
	var it model.AddSubSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sourceId", "subSourceUserName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceID = data
		case "subSourceUserName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subSourceUserName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubSourceUserName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddWeiboSubSourceInput(ctx context.Context, obj interface{}) (model.AddWeiboSubSourceInput, error) {
	var it model.AddWeiboSubSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputColumnRefreshInput(ctx context.Context, obj interface{}) (model.ColumnRefreshInput, error) {
	var it model.ColumnRefreshInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"columnId", "limit", "direction", "cursor", "otherEndCursor", "feedIds", "feedUpdatedTimes", "columnUpdatedTime", "query", "filter"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNFeedRefreshDirection2githubcomrnrcapitalnewsfeedbackendmodelFeedRefreshDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "cursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursor"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cursor = data
		case "otherEndCursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("otherEndCursor"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OtherEndCursor = data
		case "feedIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedIds = data
		case "feedUpdatedTimes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedUpdatedTimes"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedUpdatedTimes = data
		case "columnUpdatedTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnUpdatedTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnUpdatedTime = data
		case "query":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			data, err := ec.unmarshalORefreshFilterInput2githubcomrnrcapitalnewsfeedbackendmodelRefreshFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filter = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputColumnSeedStateInput(ctx context.Context, obj interface{}) (model.ColumnSeedStateInput, error) {
	var it model.ColumnSeedStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputColumnsGetPostsInput(ctx context.Context, obj interface{}) (model.ColumnsGetPostsInput, error) {
	var it model.ColumnsGetPostsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "columnsRefreshInputs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "columnsRefreshInputs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnsRefreshInputs"))
			data, err := ec.unmarshalNColumnRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelColumnRefreshInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnsRefreshInputs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCustomizedCrawlerPanopticConfigForm(ctx context.Context, obj interface{}) (model.CustomizedCrawlerPanopticConfigForm, error) {
	var it model.CustomizedCrawlerPanopticConfigForm
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "startImmediately", "scheduleEveryMilliseconds", "customizedCrawlerParams"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "startImmediately":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startImmediately"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartImmediately = data
		case "scheduleEveryMilliseconds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scheduleEveryMilliseconds"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScheduleEveryMilliseconds = data
		case "customizedCrawlerParams":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("customizedCrawlerParams"))
			data, err := ec.unmarshalNCustomizedCrawlerParams2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CustomizedCrawlerParams = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCustomizedCrawlerParams(ctx context.Context, obj interface{}) (model.CustomizedCrawlerParams, error) {
	var it model.CustomizedCrawlerParams
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"crawlUrl", "baseSelector", "titleRelativeSelector", "contentRelativeSelector", "externalIdRelativeSelector", "timeRelativeSelector", "imageRelativeSelector", "subsourceRelativeSelector", "originUrlRelativeSelector", "originUrlIsRelativePath"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "crawlUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("crawlUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CrawlURL = data
		case "baseSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseSelector"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseSelector = data
		case "titleRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleRelativeSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleRelativeSelector = data
		case "contentRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentRelativeSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContentRelativeSelector = data
		case "externalIdRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalIdRelativeSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalIDRelativeSelector = data
		case "timeRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeRelativeSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeRelativeSelector = data
		case "imageRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageRelativeSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageRelativeSelector = data
		case "subsourceRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subsourceRelativeSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubsourceRelativeSelector = data
		case "originUrlRelativeSelector":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("originUrlRelativeSelector"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OriginURLRelativeSelector = data
		case "originUrlIsRelativePath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("originUrlIsRelativePath"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OriginURLIsRelativePath = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteColumnInput(ctx context.Context, obj interface{}) (model.DeleteColumnInput, error) {
	var it model.DeleteColumnInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "columnId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteSubSourceInput(ctx context.Context, obj interface{}) (model.DeleteSubSourceInput, error) {
	var it model.DeleteSubSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subsourceId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subsourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subsourceId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubsourceID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedRefreshInput(ctx context.Context, obj interface{}) (model.FeedRefreshInput, error) {
	var it model.FeedRefreshInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"feedId", "limit", "cursor", "direction", "feedUpdatedTime", "query", "filter"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "feedId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedID = data
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "cursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursor"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cursor = data
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNFeedRefreshDirection2githubcomrnrcapitalnewsfeedbackendmodelFeedRefreshDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "feedUpdatedTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedUpdatedTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedUpdatedTime = data
		case "query":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			data, err := ec.unmarshalORefreshFilterInput2githubcomrnrcapitalnewsfeedbackendmodelRefreshFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filter = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedSeedStateInput(ctx context.Context, obj interface{}) (model.FeedSeedStateInput, error) {
	var it model.FeedSeedStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedsGetPostsInput(ctx context.Context, obj interface{}) (model.FeedsGetPostsInput, error) {
	var it model.FeedsGetPostsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "feedRefreshInputs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "feedRefreshInputs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedRefreshInputs"))
			data, err := ec.unmarshalNFeedRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelFeedRefreshInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedRefreshInputs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewPostInput(ctx context.Context, obj interface{}) (model.NewPostInput, error) {
	var it model.NewPostInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "content", "subSourceId", "feedsIdPublishTo", "sharedFromPostId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "content":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("content"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Content = data
		case "subSourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subSourceId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubSourceID = data
		case "feedsIdPublishTo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedsIdPublishTo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedsIDPublishTo = data
		case "sharedFromPostId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sharedFromPostId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SharedFromPostID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewSourceInput(ctx context.Context, obj interface{}) (model.NewSourceInput, error) {
	var it model.NewSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "name", "domain", "customizedCrawlerPanopticConfigForm"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "domain":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domain"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Domain = data
		case "customizedCrawlerPanopticConfigForm":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("customizedCrawlerPanopticConfigForm"))
			data, err := ec.unmarshalOCustomizedCrawlerPanopticConfigForm2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerPanopticConfigForm(ctx, v)
			if err != nil {
				return it, err
			}
			it.CustomizedCrawlerPanopticConfigForm = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewUserInput(ctx context.Context, obj interface{}) (model.NewUserInput, error) {
	var it model.NewUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationSettingInput(ctx context.Context, obj interface{}) (model.NotificationSettingInput, error) {
	var it model.NotificationSettingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "columnId", "mobile", "web", "unreadIndicatorOnIcon"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		case "mobile":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mobile"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mobile = data
		case "web":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("web"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Web = data
		case "unreadIndicatorOnIcon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unreadIndicatorOnIcon"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnreadIndicatorOnIcon = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPostInput(ctx context.Context, obj interface{}) (model.PostInput, error) {
	var it model.PostInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRefreshFilterInput(ctx context.Context, obj interface{}) (model.RefreshFilterInput, error) {
	var it model.RefreshFilterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"unread"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "unread":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unread"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Unread = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchPostsInput(ctx context.Context, obj interface{}) (model.SearchPostsInput, error) {
	var it model.SearchPostsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "searchPostsRefreshInput"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "searchPostsRefreshInput":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchPostsRefreshInput"))
			data, err := ec.unmarshalNSearchPostsRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelSearchPostsRefreshInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.SearchPostsRefreshInput = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchPostsRefreshInput(ctx context.Context, obj interface{}) (model.SearchPostsRefreshInput, error) {
	var it model.SearchPostsRefreshInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"limit", "direction", "cursor", "otherEndCursor", "query", "filter"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNFeedRefreshDirection2githubcomrnrcapitalnewsfeedbackendmodelFeedRefreshDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "cursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursor"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cursor = data
		case "otherEndCursor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("otherEndCursor"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OtherEndCursor = data
		case "query":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Query = data
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			data, err := ec.unmarshalORefreshFilterInput2githubcomrnrcapitalnewsfeedbackendmodelRefreshFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filter = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSeedStateInput(ctx context.Context, obj interface{}) (model.SeedStateInput, error) {
	var it model.SeedStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userSeedState", "columnSeedState"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userSeedState":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userSeedState"))
			data, err := ec.unmarshalNUserSeedStateInput2githubcomrnrcapitalnewsfeedbackendmodelUserSeedStateInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserSeedState = data
		case "columnSeedState":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnSeedState"))
			data, err := ec.unmarshalNColumnSeedStateInput2githubcomrnrcapitalnewsfeedbackendmodelColumnSeedStateInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnSeedState = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetFeedFavoriteInput(ctx context.Context, obj interface{}) (model.SetFeedFavoriteInput, error) {
	var it model.SetFeedFavoriteInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "feedId", "isFavorite"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "feedId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedID = data
		case "isFavorite":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isFavorite"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsFavorite = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetItemsReadStatusInput(ctx context.Context, obj interface{}) (model.SetItemsReadStatusInput, error) {
	var it model.SetItemsReadStatusInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "itemNodeIds", "read", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "itemNodeIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemNodeIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemNodeIds = data
		case "read":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("read"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Read = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNItemType2githubcomrnrcapitalnewsfeedbackendmodelItemType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSourcesInput(ctx context.Context, obj interface{}) (model.SourcesInput, error) {
	var it model.SourcesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subSourceFromSharedPost"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subSourceFromSharedPost":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subSourceFromSharedPost"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubSourceFromSharedPost = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscribeInput(ctx context.Context, obj interface{}) (model.SubscribeInput, error) {
	var it model.SubscribeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId", "columnId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubsourcesInput(ctx context.Context, obj interface{}) (model.SubsourcesInput, error) {
	var it model.SubsourcesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"isFromSharedPost", "isCustomized"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "isFromSharedPost":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isFromSharedPost"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsFromSharedPost = data
		case "isCustomized":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isCustomized"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsCustomized = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertColumnInput(ctx context.Context, obj interface{}) (model.UpsertColumnInput, error) {
	var it model.UpsertColumnInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"columnId", "userId", "name", "visibility", "feedIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "visibility":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibility"))
			data, err := ec.unmarshalNVisibility2githubcomrnrcapitalnewsfeedbackendmodelVisibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.Visibility = data
		case "feedIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedIds"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertFeedInput(ctx context.Context, obj interface{}) (model.UpsertFeedInput, error) {
	var it model.UpsertFeedInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"columnId", "userId", "feedId", "name", "filterDataExpression", "subSourceIds", "addToColumn"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "columnId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columnId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColumnID = data
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "feedId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "filterDataExpression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filterDataExpression"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FilterDataExpression = data
		case "subSourceIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subSourceIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubSourceIds = data
		case "addToColumn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addToColumn"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddToColumn = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpsertSubSourceInput(ctx context.Context, obj interface{}) (model.UpsertSubSourceInput, error) {
	var it model.UpsertSubSourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "externalIdentifier", "sourceId", "avatarUrl", "originUrl", "isFromSharedPost", "customizedCrawlerParams"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "externalIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalIdentifier = data
		case "sourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceID = data
		case "avatarUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarURL = data
		case "originUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("originUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OriginURL = data
		case "isFromSharedPost":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isFromSharedPost"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsFromSharedPost = data
		case "customizedCrawlerParams":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("customizedCrawlerParams"))
			data, err := ec.unmarshalOCustomizedCrawlerParams2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CustomizedCrawlerParams = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserIdInput(ctx context.Context, obj interface{}) (model.UserIDInput, error) {
	var it model.UserIDInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserSeedStateInput(ctx context.Context, obj interface{}) (model.UserSeedStateInput, error) {
	var it model.UserSeedStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "avatarUrl"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "avatarUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarURL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserStateInput(ctx context.Context, obj interface{}) (model.UserStateInput, error) {
	var it model.UserStateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ColumnSeedStateInterface(ctx context.Context, sel ast.SelectionSet, obj model.ColumnSeedStateInterface) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Column:
		return ec._Column(ctx, sel, &obj)
	case *model.Column:
		if obj == nil {
			return graphql.Null
		}
		return ec._Column(ctx, sel, obj)
	case model.ColumnSeedState:
		return ec._ColumnSeedState(ctx, sel, &obj)
	case *model.ColumnSeedState:
		if obj == nil {
			return graphql.Null
		}
		return ec._ColumnSeedState(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _FeedSeedStateInterface(ctx context.Context, sel ast.SelectionSet, obj model.FeedSeedStateInterface) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Feed:
		return ec._Feed(ctx, sel, &obj)
	case *model.Feed:
		if obj == nil {
			return graphql.Null
		}
		return ec._Feed(ctx, sel, obj)
	case model.FeedSeedState:
		return ec._FeedSeedState(ctx, sel, &obj)
	case *model.FeedSeedState:
		if obj == nil {
			return graphql.Null
		}
		return ec._FeedSeedState(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UserSeedStateInterface(ctx context.Context, sel ast.SelectionSet, obj model.UserSeedStateInterface) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.User:
		return ec._User(ctx, sel, &obj)
	case *model.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case model.UserSeedState:
		return ec._UserSeedState(ctx, sel, &obj)
	case *model.UserSeedState:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserSeedState(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var columnImplementors = []string{"Column", "ColumnSeedStateInterface"}

func (ec *executionContext) _Column(ctx context.Context, sel ast.SelectionSet, obj *model.Column) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, columnImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Column")
		case "id":
			out.Values[i] = ec._Column_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Column_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Column_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "creator":
			out.Values[i] = ec._Column_creator(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Column_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subscribers":
			out.Values[i] = ec._Column_subscribers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feeds":
			out.Values[i] = ec._Column_feeds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "visibility":
			out.Values[i] = ec._Column_visibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subscriberCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Column_subscriberCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mobileNotification":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Column_mobileNotification(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "readed":
			out.Values[i] = ec._Column_readed(ctx, field, obj)
		case "webNotification":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Column_webNotification(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "showUnreadIndicatorOnIcon":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Column_showUnreadIndicatorOnIcon(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var columnSeedStateImplementors = []string{"ColumnSeedState", "ColumnSeedStateInterface"}

func (ec *executionContext) _ColumnSeedState(ctx context.Context, sel ast.SelectionSet, obj *model.ColumnSeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, columnSeedStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ColumnSeedState")
		case "id":
			out.Values[i] = ec._ColumnSeedState_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ColumnSeedState_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customizedCrawlerTestResponseImplementors = []string{"CustomizedCrawlerTestResponse"}

func (ec *executionContext) _CustomizedCrawlerTestResponse(ctx context.Context, sel ast.SelectionSet, obj *model.CustomizedCrawlerTestResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customizedCrawlerTestResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomizedCrawlerTestResponse")
		case "baseHtml":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_baseHtml(ctx, field, obj)
		case "title":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_title(ctx, field, obj)
		case "content":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_content(ctx, field, obj)
		case "externalId":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_externalId(ctx, field, obj)
		case "time":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_time(ctx, field, obj)
		case "images":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_images(ctx, field, obj)
		case "subsource":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_subsource(ctx, field, obj)
		case "originUrl":
			out.Values[i] = ec._CustomizedCrawlerTestResponse_originUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedImplementors = []string{"Feed", "FeedSeedStateInterface"}

func (ec *executionContext) _Feed(ctx context.Context, sel ast.SelectionSet, obj *model.Feed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Feed")
		case "id":
			out.Values[i] = ec._Feed_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Feed_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Feed_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "creator":
			out.Values[i] = ec._Feed_creator(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Feed_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "posts":
			out.Values[i] = ec._Feed_posts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subSources":
			out.Values[i] = ec._Feed_subSources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "columns":
			out.Values[i] = ec._Feed_columns(ctx, field, obj)
		case "filterDataExpression":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_filterDataExpression(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "visibility":
			out.Values[i] = ec._Feed_visibility(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedSeedStateImplementors = []string{"FeedSeedState", "FeedSeedStateInterface"}

func (ec *executionContext) _FeedSeedState(ctx context.Context, sel ast.SelectionSet, obj *model.FeedSeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedSeedStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedSeedState")
		case "id":
			out.Values[i] = ec._FeedSeedState_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FeedSeedState_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "upsertFeed":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertFeed(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "upsertColumn":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertColumn(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteColumn":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteColumn(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createPost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subscribe":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_subscribe(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "upsertSubSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_upsertSubSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addWeiboSubSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addWeiboSubSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addSubSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addSubSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSubSource":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSubSource(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "syncUp":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_syncUp(ctx, field)
			})
		case "setItemsReadStatus":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setItemsReadStatus(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setFeedFavorite":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setFeedFavorite(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setNotificationSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setNotificationSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var postImplementors = []string{"Post"}

func (ec *executionContext) _Post(ctx context.Context, sel ast.SelectionSet, obj *model.Post) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Post")
		case "id":
			out.Values[i] = ec._Post_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Post_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "title":
			out.Values[i] = ec._Post_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "content":
			out.Values[i] = ec._Post_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subSource":
			out.Values[i] = ec._Post_subSource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sharedFromPost":
			out.Values[i] = ec._Post_sharedFromPost(ctx, field, obj)
		case "readByUser":
			out.Values[i] = ec._Post_readByUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "publishedFeeds":
			out.Values[i] = ec._Post_publishedFeeds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cursor":
			out.Values[i] = ec._Post_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "imageUrls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_imageUrls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fileUrls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_fileUrls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "crawledAt":
			out.Values[i] = ec._Post_crawledAt(ctx, field, obj)
		case "originUrl":
			out.Values[i] = ec._Post_originUrl(ctx, field, obj)
		case "contentGeneratedAt":
			out.Values[i] = ec._Post_contentGeneratedAt(ctx, field, obj)
		case "inSharingChain":
			out.Values[i] = ec._Post_inSharingChain(ctx, field, obj)
		case "deduplicateId":
			out.Values[i] = ec._Post_deduplicateId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "semanticHashing":
			out.Values[i] = ec._Post_semanticHashing(ctx, field, obj)
		case "embedding":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_embedding(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "replyThread":
			out.Values[i] = ec._Post_replyThread(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Post_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isRead":
			out.Values[i] = ec._Post_isRead(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "delayed":
			out.Values[i] = ec._Post_delayed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var postInColumnOutputImplementors = []string{"PostInColumnOutput"}

func (ec *executionContext) _PostInColumnOutput(ctx context.Context, sel ast.SelectionSet, obj *model.PostInColumnOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postInColumnOutputImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PostInColumnOutput")
		case "post":
			out.Values[i] = ec._PostInColumnOutput_post(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._PostInColumnOutput_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var postInFeedOutputImplementors = []string{"PostInFeedOutput"}

func (ec *executionContext) _PostInFeedOutput(ctx context.Context, sel ast.SelectionSet, obj *model.PostInFeedOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postInFeedOutputImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PostInFeedOutput")
		case "post":
			out.Values[i] = ec._PostInFeedOutput_post(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._PostInFeedOutput_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "allVisibleColumns":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allVisibleColumns(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "favoriteFeeds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_favoriteFeeds(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "post":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_post(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "posts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_posts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userState":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userState(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "feeds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_feeds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "columns":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_columns(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "subSources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_subSources(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sources(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tryCustomizedCrawler":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tryCustomizedCrawler(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var seedStateImplementors = []string{"SeedState"}

func (ec *executionContext) _SeedState(ctx context.Context, sel ast.SelectionSet, obj *model.SeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, seedStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SeedState")
		case "userSeedState":
			out.Values[i] = ec._SeedState_userSeedState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "columnSeedState":
			out.Values[i] = ec._SeedState_columnSeedState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var signalImplementors = []string{"Signal"}

func (ec *executionContext) _Signal(ctx context.Context, sel ast.SelectionSet, obj *model.Signal) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signalImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Signal")
		case "signalType":
			out.Values[i] = ec._Signal_signalType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "signalPayload":
			out.Values[i] = ec._Signal_signalPayload(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sourceImplementors = []string{"Source"}

func (ec *executionContext) _Source(ctx context.Context, sel ast.SelectionSet, obj *model.Source) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Source")
		case "id":
			out.Values[i] = ec._Source_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Source_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Source_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "creator":
			out.Values[i] = ec._Source_creator(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Source_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "domain":
			out.Values[i] = ec._Source_domain(ctx, field, obj)
		case "subsources":
			out.Values[i] = ec._Source_subsources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subSourceImplementors = []string{"SubSource"}

func (ec *executionContext) _SubSource(ctx context.Context, sel ast.SelectionSet, obj *model.SubSource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subSourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SubSource")
		case "id":
			out.Values[i] = ec._SubSource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._SubSource_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SubSource_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "name":
			out.Values[i] = ec._SubSource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalIdentifier":
			out.Values[i] = ec._SubSource_externalIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "source":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SubSource_source(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "avatarUrl":
			out.Values[i] = ec._SubSource_avatarUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "originUrl":
			out.Values[i] = ec._SubSource_originUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isFromSharedPost":
			out.Values[i] = ec._SubSource_isFromSharedPost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "customizedCrawlerParams":
			out.Values[i] = ec._SubSource_customizedCrawlerParams(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "signal":
		return ec._Subscription_signal(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var userImplementors = []string{"User", "UserSeedStateInterface"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "deletedAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_deletedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "avatarUrl":
			out.Values[i] = ec._User_avatarUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subscribedColumns":
			out.Values[i] = ec._User_subscribedColumns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "postsRead":
			out.Values[i] = ec._User_postsRead(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSeedStateImplementors = []string{"UserSeedState", "UserSeedStateInterface"}

func (ec *executionContext) _UserSeedState(ctx context.Context, sel ast.SelectionSet, obj *model.UserSeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSeedStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSeedState")
		case "id":
			out.Values[i] = ec._UserSeedState_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._UserSeedState_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "avatarUrl":
			out.Values[i] = ec._UserSeedState_avatarUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userStateImplementors = []string{"UserState"}

func (ec *executionContext) _UserState(ctx context.Context, sel ast.SelectionSet, obj *model.UserState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserState")
		case "user":
			out.Values[i] = ec._UserState_user(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddSubSourceInput2githubcomrnrcapitalnewsfeedbackendmodelAddSubSourceInput(ctx context.Context, v interface{}) (model.AddSubSourceInput, error) {
	res, err := ec.unmarshalInputAddSubSourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAddWeiboSubSourceInput2githubcomrnrcapitalnewsfeedbackendmodelAddWeiboSubSourceInput(ctx context.Context, v interface{}) (model.AddWeiboSubSourceInput, error) {
	res, err := ec.unmarshalInputAddWeiboSubSourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx context.Context, sel ast.SelectionSet, v model.Column) graphql.Marshaler {
	return ec._Column(ctx, sel, &v)
}

func (ec *executionContext) marshalNColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx context.Context, sel ast.SelectionSet, v []*model.Column) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx context.Context, sel ast.SelectionSet, v *model.Column) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Column(ctx, sel, v)
}

func (ec *executionContext) unmarshalNColumnRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelColumnRefreshInput(ctx context.Context, v interface{}) ([]*model.ColumnRefreshInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.ColumnRefreshInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNColumnRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelColumnRefreshInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNColumnRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelColumnRefreshInput(ctx context.Context, v interface{}) (*model.ColumnRefreshInput, error) {
	res, err := ec.unmarshalInputColumnRefreshInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNColumnSeedState2githubcomrnrcapitalnewsfeedbackendmodelColumnSeedState(ctx context.Context, sel ast.SelectionSet, v []*model.ColumnSeedState) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNColumnSeedState2githubcomrnrcapitalnewsfeedbackendmodelColumnSeedState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNColumnSeedState2githubcomrnrcapitalnewsfeedbackendmodelColumnSeedState(ctx context.Context, sel ast.SelectionSet, v *model.ColumnSeedState) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ColumnSeedState(ctx, sel, v)
}

func (ec *executionContext) unmarshalNColumnSeedStateInput2githubcomrnrcapitalnewsfeedbackendmodelColumnSeedStateInput(ctx context.Context, v interface{}) ([]*model.ColumnSeedStateInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.ColumnSeedStateInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNColumnSeedStateInput2githubcomrnrcapitalnewsfeedbackendmodelColumnSeedStateInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNColumnSeedStateInput2githubcomrnrcapitalnewsfeedbackendmodelColumnSeedStateInput(ctx context.Context, v interface{}) (*model.ColumnSeedStateInput, error) {
	res, err := ec.unmarshalInputColumnSeedStateInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCustomizedCrawlerParams2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerParams(ctx context.Context, v interface{}) (*model.CustomizedCrawlerParams, error) {
	res, err := ec.unmarshalInputCustomizedCrawlerParams(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCustomizedCrawlerTestResponse2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerTestResponse(ctx context.Context, sel ast.SelectionSet, v *model.CustomizedCrawlerTestResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CustomizedCrawlerTestResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteColumnInput2githubcomrnrcapitalnewsfeedbackendmodelDeleteColumnInput(ctx context.Context, v interface{}) (model.DeleteColumnInput, error) {
	res, err := ec.unmarshalInputDeleteColumnInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx context.Context, sel ast.SelectionSet, v model.Feed) graphql.Marshaler {
	return ec._Feed(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx context.Context, sel ast.SelectionSet, v []*model.Feed) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx context.Context, sel ast.SelectionSet, v *model.Feed) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Feed(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFeedRefreshDirection2githubcomrnrcapitalnewsfeedbackendmodelFeedRefreshDirection(ctx context.Context, v interface{}) (model.FeedRefreshDirection, error) {
	var res model.FeedRefreshDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeedRefreshDirection2githubcomrnrcapitalnewsfeedbackendmodelFeedRefreshDirection(ctx context.Context, sel ast.SelectionSet, v model.FeedRefreshDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFeedRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelFeedRefreshInput(ctx context.Context, v interface{}) ([]*model.FeedRefreshInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FeedRefreshInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFeedRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelFeedRefreshInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFeedRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelFeedRefreshInput(ctx context.Context, v interface{}) (*model.FeedRefreshInput, error) {
	res, err := ec.unmarshalInputFeedRefreshInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) ([]float64, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFloat2float64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v []float64) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNFloat2float64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int32(ctx context.Context, v interface{}) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	res := graphql.MarshalInt32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNItemType2githubcomrnrcapitalnewsfeedbackendmodelItemType(ctx context.Context, v interface{}) (model.ItemType, error) {
	var res model.ItemType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemType2githubcomrnrcapitalnewsfeedbackendmodelItemType(ctx context.Context, sel ast.SelectionSet, v model.ItemType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNNewPostInput2githubcomrnrcapitalnewsfeedbackendmodelNewPostInput(ctx context.Context, v interface{}) (model.NewPostInput, error) {
	res, err := ec.unmarshalInputNewPostInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewSourceInput2githubcomrnrcapitalnewsfeedbackendmodelNewSourceInput(ctx context.Context, v interface{}) (model.NewSourceInput, error) {
	res, err := ec.unmarshalInputNewSourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewUserInput2githubcomrnrcapitalnewsfeedbackendmodelNewUserInput(ctx context.Context, v interface{}) (model.NewUserInput, error) {
	res, err := ec.unmarshalInputNewUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNotificationSettingInput2githubcomrnrcapitalnewsfeedbackendmodelNotificationSettingInput(ctx context.Context, v interface{}) (model.NotificationSettingInput, error) {
	res, err := ec.unmarshalInputNotificationSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx context.Context, sel ast.SelectionSet, v model.Post) graphql.Marshaler {
	return ec._Post(ctx, sel, &v)
}

func (ec *executionContext) marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx context.Context, sel ast.SelectionSet, v []*model.Post) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx context.Context, sel ast.SelectionSet, v *model.Post) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Post(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSearchPostsRefreshInput2githubcomrnrcapitalnewsfeedbackendmodelSearchPostsRefreshInput(ctx context.Context, v interface{}) (*model.SearchPostsRefreshInput, error) {
	res, err := ec.unmarshalInputSearchPostsRefreshInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSetFeedFavoriteInput2githubcomrnrcapitalnewsfeedbackendmodelSetFeedFavoriteInput(ctx context.Context, v interface{}) (model.SetFeedFavoriteInput, error) {
	res, err := ec.unmarshalInputSetFeedFavoriteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSetItemsReadStatusInput2githubcomrnrcapitalnewsfeedbackendmodelSetItemsReadStatusInput(ctx context.Context, v interface{}) (model.SetItemsReadStatusInput, error) {
	res, err := ec.unmarshalInputSetItemsReadStatusInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSignal2githubcomrnrcapitalnewsfeedbackendmodelSignal(ctx context.Context, sel ast.SelectionSet, v model.Signal) graphql.Marshaler {
	return ec._Signal(ctx, sel, &v)
}

func (ec *executionContext) marshalNSignal2githubcomrnrcapitalnewsfeedbackendmodelSignal(ctx context.Context, sel ast.SelectionSet, v *model.Signal) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Signal(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSignalType2githubcomrnrcapitalnewsfeedbackendmodelSignalType(ctx context.Context, v interface{}) (model.SignalType, error) {
	var res model.SignalType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSignalType2githubcomrnrcapitalnewsfeedbackendmodelSignalType(ctx context.Context, sel ast.SelectionSet, v model.SignalType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSource2githubcomrnrcapitalnewsfeedbackendmodelSource(ctx context.Context, sel ast.SelectionSet, v model.Source) graphql.Marshaler {
	return ec._Source(ctx, sel, &v)
}

func (ec *executionContext) marshalNSource2githubcomrnrcapitalnewsfeedbackendmodelSource(ctx context.Context, sel ast.SelectionSet, v *model.Source) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx context.Context, sel ast.SelectionSet, v model.SubSource) graphql.Marshaler {
	return ec._SubSource(ctx, sel, &v)
}

func (ec *executionContext) marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx context.Context, sel ast.SelectionSet, v []model.SubSource) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx context.Context, sel ast.SelectionSet, v []*model.SubSource) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSubSource2githubcomrnrcapitalnewsfeedbackendmodelSubSource(ctx context.Context, sel ast.SelectionSet, v *model.SubSource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SubSource(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSubscribeInput2githubcomrnrcapitalnewsfeedbackendmodelSubscribeInput(ctx context.Context, v interface{}) (model.SubscribeInput, error) {
	res, err := ec.unmarshalInputSubscribeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpsertColumnInput2githubcomrnrcapitalnewsfeedbackendmodelUpsertColumnInput(ctx context.Context, v interface{}) (model.UpsertColumnInput, error) {
	res, err := ec.unmarshalInputUpsertColumnInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpsertFeedInput2githubcomrnrcapitalnewsfeedbackendmodelUpsertFeedInput(ctx context.Context, v interface{}) (model.UpsertFeedInput, error) {
	res, err := ec.unmarshalInputUpsertFeedInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpsertSubSourceInput2githubcomrnrcapitalnewsfeedbackendmodelUpsertSubSourceInput(ctx context.Context, v interface{}) (model.UpsertSubSourceInput, error) {
	res, err := ec.unmarshalInputUpsertSubSourceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSeedState2githubcomrnrcapitalnewsfeedbackendmodelUserSeedState(ctx context.Context, sel ast.SelectionSet, v *model.UserSeedState) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSeedState(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserSeedStateInput2githubcomrnrcapitalnewsfeedbackendmodelUserSeedStateInput(ctx context.Context, v interface{}) (*model.UserSeedStateInput, error) {
	res, err := ec.unmarshalInputUserSeedStateInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserState2githubcomrnrcapitalnewsfeedbackendmodelUserState(ctx context.Context, sel ast.SelectionSet, v model.UserState) graphql.Marshaler {
	return ec._UserState(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserState2githubcomrnrcapitalnewsfeedbackendmodelUserState(ctx context.Context, sel ast.SelectionSet, v *model.UserState) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserState(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserStateInput2githubcomrnrcapitalnewsfeedbackendmodelUserStateInput(ctx context.Context, v interface{}) (model.UserStateInput, error) {
	res, err := ec.unmarshalInputUserStateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNVisibility2githubcomrnrcapitalnewsfeedbackendmodelVisibility(ctx context.Context, v interface{}) (model.Visibility, error) {
	var res model.Visibility
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVisibility2githubcomrnrcapitalnewsfeedbackendmodelVisibility(ctx context.Context, sel ast.SelectionSet, v model.Visibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx context.Context, sel ast.SelectionSet, v []*model.Column) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNColumn2githubcomrnrcapitalnewsfeedbackendmodelColumn(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOColumnsGetPostsInput2githubcomrnrcapitalnewsfeedbackendmodelColumnsGetPostsInput(ctx context.Context, v interface{}) (*model.ColumnsGetPostsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputColumnsGetPostsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCustomizedCrawlerPanopticConfigForm2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerPanopticConfigForm(ctx context.Context, v interface{}) (*model.CustomizedCrawlerPanopticConfigForm, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCustomizedCrawlerPanopticConfigForm(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCustomizedCrawlerParams2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerParams(ctx context.Context, v interface{}) (*model.CustomizedCrawlerParams, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCustomizedCrawlerParams(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCustomizedCrawlerTestResponse2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerTestResponse(ctx context.Context, sel ast.SelectionSet, v []*model.CustomizedCrawlerTestResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCustomizedCrawlerTestResponse2githubcomrnrcapitalnewsfeedbackendmodelCustomizedCrawlerTestResponse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODeleteSubSourceInput2githubcomrnrcapitalnewsfeedbackendmodelDeleteSubSourceInput(ctx context.Context, v interface{}) (*model.DeleteSubSourceInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDeleteSubSourceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx context.Context, sel ast.SelectionSet, v []*model.Feed) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeed2githubcomrnrcapitalnewsfeedbackendmodelFeed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFeedsGetPostsInput2githubcomrnrcapitalnewsfeedbackendmodelFeedsGetPostsInput(ctx context.Context, v interface{}) (*model.FeedsGetPostsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedsGetPostsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx context.Context, sel ast.SelectionSet, v []*model.Post) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPost2githubcomrnrcapitalnewsfeedbackendmodelPost(ctx context.Context, sel ast.SelectionSet, v *model.Post) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Post(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPostInput2githubcomrnrcapitalnewsfeedbackendmodelPostInput(ctx context.Context, v interface{}) (*model.PostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORefreshFilterInput2githubcomrnrcapitalnewsfeedbackendmodelRefreshFilterInput(ctx context.Context, v interface{}) (*model.RefreshFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRefreshFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchPostsInput2githubcomrnrcapitalnewsfeedbackendmodelSearchPostsInput(ctx context.Context, v interface{}) (*model.SearchPostsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchPostsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSeedState2githubcomrnrcapitalnewsfeedbackendmodelSeedState(ctx context.Context, sel ast.SelectionSet, v *model.SeedState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SeedState(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSeedStateInput2githubcomrnrcapitalnewsfeedbackendmodelSeedStateInput(ctx context.Context, v interface{}) (*model.SeedStateInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSeedStateInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSource2githubcomrnrcapitalnewsfeedbackendmodelSource(ctx context.Context, sel ast.SelectionSet, v []*model.Source) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSource2githubcomrnrcapitalnewsfeedbackendmodelSource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSourcesInput2githubcomrnrcapitalnewsfeedbackendmodelSourcesInput(ctx context.Context, v interface{}) (*model.SourcesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSourcesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOSubsourcesInput2githubcomrnrcapitalnewsfeedbackendmodelSubsourcesInput(ctx context.Context, v interface{}) (*model.SubsourcesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSubsourcesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) ([]*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []*time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOTime2timeTime(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUser2githubcomrnrcapitalnewsfeedbackendmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserIdInput2githubcomrnrcapitalnewsfeedbackendmodelUserIDInput(ctx context.Context, v interface{}) (*model.UserIDInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserIdInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOVisibility2githubcomrnrcapitalnewsfeedbackendmodelVisibility(ctx context.Context, v interface{}) (model.Visibility, error) {
	var res model.Visibility
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVisibility2githubcomrnrcapitalnewsfeedbackendmodelVisibility(ctx context.Context, sel ast.SelectionSet, v model.Visibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
